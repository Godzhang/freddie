<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <!-- <script src="./js/data-structure.js"></script> -->
    <script src="./js/binarySearchTree.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
    </style>
    <title>algorithm</title>
  </head>

  <body>
    <div class="container"></div>

    <script>
      //
    </script>
    <script>
      //
    </script>
    <script>
      //
    </script>
    <script>
      //
    </script>
    <script>
      //
    </script>
    <script>
      //
      // f(i)(x) = Math.mix(f(i-1)(^x), f(i-1)(^x)) + costs[i][x]
      // const costs = [
      //   [17, 2, 17],
      //   [16, 16, 5],
      //   [14, 3, 19],
      // ];
      // const minCost = (costs) => {
      //   if (!costs || !costs.length) return 0;
      //   const len = costs.length;
      //   const f = new Array(len);
      //   for (let i = 0; i < len; i++) {
      //     f[i] = new Array(3);
      //   }
      //   f[0][0] = costs[0][0];
      //   f[0][1] = costs[0][1];
      //   f[0][2] = costs[0][2];
      //   for (let i = 1; i < len; i++) {
      //     f[i][0] = Math.min(f[i - 1][1], f[i - 1][2]) + costs[i][0];
      //     f[i][1] = Math.min(f[i - 1][0], f[i - 1][2]) + costs[i][1];
      //     f[i][2] = Math.min(f[i - 1][0], f[i - 1][1]) + costs[i][2];
      //   }
      //   return Math.min(f[len - 1][0], f[len - 1][1], f[len - 1][2]);
      // };
      // 优化，使用滚动数组
      // const minCost = (costs) => {
      //   if (!costs || !costs.length) return 0;
      //   const len = costs.length;
      //   for (let i = 1; i < len; i++) {
      //     const now = costs[i];
      //     const prev = costs[i - 1];
      //     now[0] += Math.min(prev[1], prev[2]);
      //     now[1] += Math.min(prev[0], prev[2]);
      //     now[2] += Math.min(prev[0], prev[1]);
      //   }
      //   return Math.min.apply(Math, costs[len - 1]);
      // };
      // console.log(minCost(costs));
    </script>
    <script>
      // O(log(m+n))
      // const findMedianSortedArrays = (nums1, nums2) => {
      //   const len1 = nums1.length;
      //   const len2 = nums2.length;
      //   if (len1 > len2) {
      //     return findMedianSortedArrays(nums2, nums1);
      //   }
      //   const len = len1 + len2;
      //   let slice1 = 0;
      //   let slice2 = 0;
      //   let slice1L = 0;
      //   let slice1R = len1;
      //   while (slice1 <= len1) {
      //     slice1 = Math.floor((slice1R - slice1L) / 2) + slice1L;
      //     slice2 = Math.floor(len / 2) - slice1;
      //     const L1 = slice1 === 0 ? -Infinity : nums1[slice1 - 1];
      //     const L2 = slice2 === 0 ? -Infinity : nums2[slice2 - 1];
      //     const R1 = slice1 === len1 ? Infinity : nums1[slice1];
      //     const R2 = slice2 === len2 ? Infinity : nums2[slice2];

      //     if (L1 > R2) {
      //       slice1R = slice1 - 1;
      //     } else if (L2 > R1) {
      //       slice1L = slice1 + 1;
      //     } else {
      //       if (len % 2 === 0) {
      //         const L = L1 > L2 ? L1 : L2;
      //         const R = R1 < R2 ? R1 : R2;
      //         return (L + R) / 2;
      //       } else {
      //         const median = R1 < R2 ? R1 : R2;
      //         return median;
      //       }
      //     }
      //   }
      //   return -1;
      // };
      // O(m+n)
      // const findMedianSortedArrays = (nums1, nums2) => {
      //   const len1 = nums1.length;
      //   const len2 = nums2.length;
      //   const len = len1 + len2;
      //   const middleIndex = ~~(len / 2);
      //   const arr = [];
      //   let i = 0,
      //     j = 0;
      //   while (i < len1 && j < len2) {
      //     if (nums1[i] < nums2[j]) {
      //       arr.push(nums1[i]);
      //       i++;
      //     } else {
      //       arr.push(nums2[j]);
      //       j++;
      //     }
      //   }
      //   while (i < len1) {
      //     arr.push(nums1[i]);
      //     i++;
      //   }
      //   while (j < len2) {
      //     arr.push(nums2[j]);
      //     j++;
      //   }
      //   return len % 2 === 0
      //     ? (arr[middleIndex] + arr[middleIndex - 1]) / 2
      //     : arr[middleIndex];
      // };
      // console.log(findMedianSortedArrays([1, 3], [2]));
      // console.log(findMedianSortedArrays([1, 2], [3, 4]));
    </script>
    <script>
      // [3,5,1,6,2,0,8,null,null,7,4]
      // const tree = {
      //   val: 3,
      //   left: { val: 5, left: { val: 6, left: null, right: null }, right: { val: 2, left: { val: 7, left: null, right: null }, right: { val: 4, left: null, right: null } } },
      //   right: { val: 1, left: { val: 0, left: null, right: null }, right: { val: 8, left: null, right: null } }
      // }
      // const findNearestAncstor = (root, p, q) => { }
      // console.log(findNearestAncstor(tree, 5, 1))
      // console.log(findNearestAncstor(tree, 5, 4))
    </script>
    <script>
      //
      // const mergeSection = arr => {
      //   const res = []
      //   const len = arr.length

      //   if (!arr || !len) return []

      //   arr.sort((a, b) => a[0] - b[0])
      //   res.push(arr[0])

      //   for (let i = 1; i < len; i++) {
      //     const prev = res[res.length - 1]
      //     if (prev[1] >= arr[i][0]) {
      //       prev[1] = Math.max(prev[1], arr[i][1])
      //     } else {
      //       res.push(arr[i])
      //     }
      //   }
      //   return res
      // }
      // console.log(mergeSection([[1, 3], [2, 6], [8, 10], [15, 18]]))
      // console.log(mergeSection([[1, 4], [4, 5]]))
      // console.log(mergeSection([[1, 4], [2, 3]]))
    </script>
    <script>
      //
      // const room = [
      //   [1, 1, 1, 1, 1, 0, 1, 1],
      //   [1, 1, 1, 1, 1, 0, 1, 1],
      //   [1, 0, 1, 1, 1, 1, 1, 1],
      //   [0, 0, 0, 1, 0, 0, 0, 0],
      //   [1, 1, 1, 1, 1, 1, 1, 1],
      // ];
      // const cleanRoom = robot => {
      //   const boxSet = new Set()
      //   let dir = 0
      //   dfs(robot, boxSet, 0, 0, 0)

      //   function dfs(robot, boxSet, i, j, dir) {
      //     let box = `${i}+${j}`
      //     if (boxSet.has(box)) return
      //     robot.clean()
      //     boxSet.add(box)

      //     for (let k = 0; k < 4; k++) {
      //       let x = i, y = j
      //       switch (dir) {
      //         case 0:
      //           x = i - 1
      //           break
      //         case 90:
      //           y = j + 1
      //           break
      //         case 180:
      //           x = i + 1
      //           break
      //         case 270:
      //           y = j - 1
      //           break
      //         default:
      //           break
      //       }
      //       dfs(robot, boxSet, x, y, dir)
      //       robot.turnLeft()
      //       robot.turnLeft()
      //       robot.move()
      //       robot.turnRight()
      //       robot.turnRight()
      //     }
      //     robot.turnRight()
      //     dir += 90
      //     dir %= 90
      //   }
      // }
    </script>
    <script>
      //
      // const numIslands = grid => {
      //     if (!grid || grid.length === 0 || grid[0].length === 0) return
      //     const moveX = [0, 1, 0, -1]
      //     const moveY = [1, 0, -1, 0]
      //     let count = 0
      //     const row = grid.length
      //     const col = grid[0].length
      //     for (let i = 0; i < row; i++) {
      //         for (let j = 0; j < col; j++) {
      //             if (grid[i][j] === '1') {
      //                 dfs(grid, i, j)
      //                 count++
      //             }
      //         }
      //     }

      //     function dfs(grid, i, j) {
      //         if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return
      //         grid[i][j] = '0'
      //         for (let k = 0; k < 4; k++) {
      //             dfs(grid, i + moveX[k], j + moveY[k])
      //         }
      //     }

      //     return count
      // }
      // console.log(numIslands([
      //     ['1', '1', '0', '0', '0'],
      //     ['1', '1', '0', '0', '0'],
      //     ['0', '0', '1', '0', '0'],
      //     ['0', '0', '0', '1', '1'],
      // ]))
    </script>
    <script>
      //
      // let preorder = [3, 9, 20, 15, 7]
      // let inorder = [9, 3, 15, 20, 7]
      // let postorder = [9, 15, 7, 20, 3]
      // const buildTree = (preorder, inorder) => {
      //   const len = preorder.length
      //   const build = (preL, preR, inL, inR) => {
      //     if (preL > preR) return null
      //     const root = new TreeNode(preorder[preL])
      //     const k = inorder.indexOf(root.val)
      //     const numsLeft = k - inL
      //     root.left = build(preL + 1, preL + numsLeft, inL, k - 1)
      //     root.right = build(preL + numsLeft + 1, preR, k + 1, inR)
      //     return root

      //   }
      //   return build(0, len - 1, 0, len - 1)
      // }
      // console.log(buildTree(preorder, inorder))

      // const buildTree = (inorder, postorder) => {
      //     const len = inorder.length
      //     const build = (inL, inR, postL, postR) => {
      //         if (postL > postR) return null
      //         const root = new TreeNode(postorder[postR])
      //         const k = inorder.indexOf(root.val)
      //         const numsLeft = k - inL
      //         root.left = build(inL, k - 1, postL, postL + numsLeft - 1)
      //         root.right = build(k + 1, inR, postL + numsLeft, postR - 1)
      //         return root
      //     }
      //     return build(0, len - 1, 0, len - 1)
      // }
      // console.log(buildTree(inorder, postorder))
    </script>
    <script>
      // 最长回文子串
      // const isPalidrome = (str, i, j) => {
      //   while (i >= 0 && j < str.length && str[i] === str[j]) {
      //     i--
      //     j++
      //   }
      //   return str.substring(i + 1, j)
      // }
      // const longestPalindrome = (str) => {
      //   let res = ''
      //   for (let i = 0; i < str.length; i++) {
      //     let l1 = isPalidrome(str, i, i)
      //     let l2 = isPalidrome(str, i, i + 1)
      //     res = res.length >= l1.length ? res : l1
      //     res = res.length >= l2.length ? res : l2
      //   }
      //   return res
      // };
      // console.log(longestPalindrome('abc'))
      // console.log(longestPalindrome('abac'))
    </script>
    <script>
      // 最长上升子序列
      //   const lengthOfLIS = (nums) => {
      //     const len = nums.length;
      //     if (!len) return 0;
      //     const dp = new Array(len).fill(1);
      //     let maxLen = 1;
      //     for (let i = 1; i < len; i++) {
      //       for (let j = 0; j < i; j++) {
      //         if (nums[j] < nums[i]) {
      //           dp[i] = Math.max(dp[i], dp[j] + 1);
      //         }
      //       }
      //       if (dp[i] > maxLen) maxLen = dp[i];
      //     }
      //     return maxLen;
      //   };
      //   console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]));
    </script>
    <script>
      //
      //   const coinChange = (coins, amount) => {
      //     // 用于保存每个目标总额对应的最小硬币个数
      //     const f = [];
      //     // 提前定义已知情况
      //     f[0] = 0;
      //     for (let i = 1; i <= amount; i++) {
      //       f[i] = Infinity;
      //       for (let j = 0; j < coins.length; j++) {
      //         if (i - coins[j] >= 0) {
      //           f[i] = Math.min(f[i], f[i - coins[j]] + 1);
      //         }
      //       }
      //     }
      //     return f[amount] === Infinity ? -1 : f[amount];
      //   };
      //   console.log(coinChange([1,2,5], 11))
      //   console.log(coinChange([2], 3))
    </script>
    <script>
      //
      // const partition = (arr, left, right) => {
      //   const pivotValue = arr[~~(left + (right - left) / 2)]
      //   let i = left
      //   let j = right
      //   while (i <= j) {
      //     while (arr[i] < pivotValue) {
      //       i++
      //     }
      //     while (arr[j] > pivotValue) {
      //       j--
      //     }
      //     if (i <= j) {
      //       [arr[i], arr[j]] = [arr[j], arr[i]]
      //       i++
      //       j--
      //     }
      //   }
      //   return i
      // }
      // const quickSort = (arr, left = 0, right = arr.length - 1) => {
      //   if (arr.length <= 1) return arr
      //   const lineIndex = partition(arr, left, right)
      //   if (left < lineIndex - 1) {
      //     quickSort(arr, left, lineIndex - 1)
      //   }
      //   if (lineIndex < right) {
      //     quickSort(arr, lineIndex, right)
      //   }

      //   return arr
      // }
      // console.log(quickSort([4, 2, 7, 3, 1]));
    </script>
    <script>
      //
      // const mergeNums = (left, right) => {
      //   if (left[left.length - 1] <= right[0]) return left.concat(right)
      //   const res = []
      //   while (left.length && right.length) {
      //     if (left[0] < right[0]) {
      //       res.push(left.shift())
      //     } else {
      //       res.push(right.shift())
      //     }
      //   }
      //   if (left.length) {
      //     res.push(...left)
      //   }
      //   if (right.length) {
      //     res.push(...right)
      //   }
      //   return res
      // }
      // const mergeSort = (arr) => {
      //   if (arr.length === 1) return arr
      //   const len = arr.length;
      //   const mid = ~~(len / 2)
      //   const left = arr.slice(0, mid)
      //   const right = arr.slice(mid)
      //   return mergeNums(mergeSort(left), mergeSort(right))
      // };
      // console.log(mergeSort([4, 2, 7, 3, 1]));
    </script>
    <script>
      //
      // const insertSort = (arr) => {
      //   const len = arr.length;
      //   let temp;
      //   for (let i = 1; i < len; i++) {
      //     let j = i;
      //     temp = arr[i];
      //     while (j > 0 && arr[j - 1] > temp) {
      //       arr[j] = arr[j - 1];
      //       j--;
      //     }
      //     arr[j] = temp;
      //   }
      //   return arr;
      // };
      // console.log(insertSort([4, 2, 7, 3, 1]));
    </script>
    <script>
      //
      // const selectSort = (arr) => {
      //   const len = arr.length;
      //   for (let i = 0; i < len; i++) {
      //     let minIndex = i;
      //     for (let j = i + 1; j < len; j++) {
      //       if (arr[j] < arr[minIndex]) {
      //         minIndex = j;
      //       }
      //     }
      //     if (minIndex !== i) {
      //       [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
      //     }
      //   }
      //   return arr;
      // };
      // console.log(selectSort([4, 2, 7, 3, 1]));
    </script>
    <script>
      //
      // const bubbleSort = (arr, count = 0) => {
      //   const len = arr.length;
      //   for (let i = 0; i < len; i++) {
      //     let flag = true;
      //     for (let j = 0; j < len - 1 - i; j++) {
      //       count++;
      //       if (arr[j] > arr[j + 1]) {
      //         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      //         flag = false;
      //       }
      //     }
      //     if (flag) {
      //       console.log(count);
      //       return arr;
      //     }
      //   }
      //   console.log(count);
      //   return arr;
      // };
      // console.log(bubbleSort([4, 2, 7, 3, 1]));
      // console.log(bubbleSort([1, 2, 3, 4, 5]));
    </script>
    <script>
      // 构造平衡二叉树
      // const root = BinarySearchTree.from([1, 2, 3, 4]).root;
      // const root2 = BinarySearchTree.from([2, 1, 3, 4]).root;
      // const balanceBST = (root) => {
      //   const nums = [];
      //   const inorder = (root) => {
      //     if (!root) return;
      //     inorder(root.left);
      //     nums.push(root.val);
      //     inorder(root.right);
      //   };
      //   const buildAVL = (low, high) => {
      //     if (low > high) return null;
      //     const middle = Math.floor(low + (high - low) / 2);
      //     const curr = new TreeNode(nums[middle]);
      //     curr.left = buildAVL(low, middle - 1);
      //     curr.right = buildAVL(middle + 1, high);
      //     return curr;
      //   };

      //   inorder(root);
      //   return buildAVL(0, nums.length);
      // };
      // console.log(balanceBST(root));
      // console.log(balanceBST(root2));
    </script>
    <script>
      // 判断是否是平衡二叉树
      // const root = BinarySearchTree.from([5, 4, 3, 2, 1]).root;
      // const root2 = BinarySearchTree.from([6, 3, 9, 1, 4]).root;
      // const isBalanceTree = (root) => {
      //   let flag = true;
      //   const dfs = (root) => {
      //     if (!root || !flag) return 0;
      //     const left = dfs(root.left);
      //     const right = dfs(root.right);
      //     if (Math.abs(left - right) > 1) {
      //       flag = false;
      //       return 0;
      //     }
      //     return Math.max(left, right) + 1;
      //   };
      //   dfs(root);
      //   return flag;
      // };
      // console.log(isBalanceTree(root));
      // console.log(isBalanceTree(root2));
    </script>
    <script>
      //
      // const arr = [-10, -3, 0, 5, 9];
      // method 1 此方法会造成每一遍只会向左子树或右子树添加，不算对
      // const sortedArrayToBST = (arr) => {
      //   const len = arr.length;

      //   if (!len) return null;

      //   const middle = ~~(len / 2);
      //   const root = new TreeNode(arr[middle]);
      //   let prev = middle - 1;
      //   let next = middle + 1;

      //   const insertNode = (node, val) => {
      //     if (node.val > val) {
      //       if (node.left) {
      //         insertNode(node.left, val);
      //       } else {
      //         node.left = { val };
      //       }
      //     } else {
      //       if (node.right) {
      //         insertNode(node.right, val);
      //       } else {
      //         node.right = { val };
      //       }
      //     }
      //   };

      //   while (prev > -1 || next < len) {
      //     if (prev > -1) {
      //       insertNode(root, arr[prev]);
      //       prev--;
      //     }
      //     if (next < len) {
      //       insertNode(root, arr[next]);
      //       next++;
      //     }
      //   }

      //   return root;
      // };
      // method 2 每次从中间取值，更平衡
      // const sortedArrayToBST = (arr) => {
      //   if (!arr.length) return null;
      //   const root = buildBST(0, arr.length - 1);
      //   function buildBST(low, high) {
      //     if (low > high) {
      //       return null;
      //     }
      //     const mid = Math.floor(low + (high - low) / 2);
      //     const curr = new TreeNode(arr[mid]);
      //     curr.left = buildBST(low, mid - 1);
      //     curr.right = buildBST(mid + 1, high);
      //     return curr;
      //   }
      //   return root;
      // };
      // method 3
      // const sortedArrayToBST = (arr) => {
      //   if (!arr.length) return null;
      //   let middle = ~~(arr.length / 2);
      //   const root = {
      //     val: arr[middle],
      //     left: middle > 0 ? sortedArrayToBST(arr.slice(0, middle)) : null,
      //     right:
      //       middle < arr.length - 1
      //         ? sortedArrayToBST(arr.slice(middle + 1, arr.length))
      //         : null,
      //   };
      //   return root;
      // };
      // console.log(sortedArrayToBST(arr));
    </script>
    <script>
      //
      // const root = BinarySearchTree.from([6, 3, 8, 2, 1, 25, 4, 9]).root;
      // const root2 = {
      //   val: 5,
      //   left: { val: 1, left: null, right: null },
      //   right: { val: 8, left: { val: 6, left: null, right: null }, right: { val: 9, left: { val: 7, left: null, right: null }, right: null } }
      // }
      // const validateTree = (root) => {
      //   const dfs = (root, minValue, maxValue) => {
      //     if (!root) return true
      //     if (root.val <= minValue || root.val >= maxValue) {
      //       // console.log(root.val, minValue, maxValue)
      //       return false
      //     }
      //     return dfs(root.left, minValue, root.val) && dfs(root.right, root.val, maxValue)
      //   }
      //   return dfs(root, -Infinity, Infinity)
      // };
      // console.log(validateTree(root));
      // console.log(validateTree(root2));
    </script>
    <script>
      // 翻转二叉树
      //   const root = {
      //     val: 1,
      //     left: {
      //       val: 2,
      //       left: { val: 4, left: null, right: null },
      //       right: { val: 5, left: null, right: null },
      //     },
      //     right: {
      //       val: 3,
      //       left: { val: 6, left: null, right: null },
      //       right: { val: 7, left: null, right: null },
      //     },
      //   };
      //   const reverseTree = (root) => {
      //     if (root) {
      //       [root.left, root.right] = [root.right, root.left];
      //       root.left = reverseTree(root.left);
      //       root.right = reverseTree(root.right);
      //     }
      //     return root;
      //   };
      //   console.log(reverseTree(root));
    </script>
    <script>
      // 层序遍历
      // const root = {
      //   val: 3,
      //   left: { val: 9, left: null, right: null },
      //   right: {
      //     val: 20,
      //     left: { val: 15, left: null, right: null },
      //     right: { val: 7, left: null, right: null }
      //   }
      // }
      // const root2 = {
      //   val: 1,
      //   left: { val: 2, left: { val: 4, left: null, right: null }, right: { val: 5, left: null, right: null } },
      //   right: {
      //     val: 3,
      //     left: { val: 6, left: null, right: null },
      //     right: { val: 7, left: null, right: null }
      //   }
      // }
      // const fn = root => {
      //   const res = []
      //   if (!root) return res
      //   const queue = [root]

      //   while (queue.length) {
      //     const arr = []
      //     let len = queue.length

      //     while (len) {
      //       const curr = queue.shift()
      //       arr.push(curr.val)
      //       if (curr.left) {
      //         queue.push(curr.left)
      //       }
      //       if (curr.right) {
      //         queue.push(curr.right)
      //       }
      //       len--
      //     }
      //     res.push(arr)
      //   }
      //   return res
      // }
      // console.log(fn(null))
      // console.log(fn(root))
      // console.log(fn(root2))
    </script>
    <script>
      // 迭代法遍历树
      // const root = {
      //   val: 1,
      //   left:{val:2,left:null,right:null},
      //   right:{
      //     val: 3,
      //     left: {val:4,left:null,right:null},
      //     right: null
      //   }
      // }
      // 先序
      // const preOrder = root => {
      //   const res = []
      //   if(!root) return res
      //   const stack = [root]

      //   while(stack.length) {
      //     const curr= stack.pop()
      //     res.push(curr.val)
      //     if (curr.right) {
      //       stack.push(curr.right)
      //     }
      //     if (curr.left) {
      //       stack.push(curr.left)
      //     }
      //   }

      //   return res
      // }
      // console.log(preOrder(root))

      // 后序
      // const postOrder = root => {
      //   const res = []
      //   if(!root) return res
      //   const stack = [root]

      //   while(stack.length) {
      //     const curr = stack.pop()
      //     res.unshift(curr.val)

      //     if (curr.left) stack.push(curr.left)
      //     if (curr.right) stack.push(curr.right)
      //   }

      //   return res
      // }
      // console.log(postOrder(root))

      // 中序
      // const inOrder = root => {
      //     const res = []
      //     if(!root) return res
      //     const stack = []
      //     let curr = root

      //     while(curr || stack.length) {
      //       while (curr) {
      //         stack.push(curr)
      //         curr = curr.left
      //       }
      //       curr = stack.pop()
      //       res.push(curr.val)
      //       curr = curr.right
      //     }

      //     return res
      // }
      // console.log(inOrder(root))
    </script>
    <script>
      // 限定组合
      // const fn = (n,k) => {
      //   const res = []
      //   const curr = []
      //   const dfs = index => {
      //     if (curr.length === k) {
      //       res.push(curr.slice())
      //       return
      //     }
      //     for(let i = index;i<=n;i++) {
      //       curr.push(i)
      //       dfs(i+1)
      //       curr.pop()
      //     }
      //   }
      //   dfs(1)
      //   return res
      // }
      // console.log(fn(4,2))
    </script>
    <script>
      // 所有可能子集
      // const arr = [1,2,3]
      // const subsets = nums => {
      //   const len = nums.length
      //   const res = []
      //   const curr = []

      //   const dfs = index => {
      //     res.push(curr.slice())
      //     for(let i = index;i<len;i++) {
      //       curr.push(nums[i])
      //       dfs(i+1)
      //       curr.pop()
      //     }
      //   }
      //   dfs(0)
      //   return res
      // }
      // console.log(subsets(arr))
    </script>
    <script>
      // 全排列组合
      // const arr= [1,2,3];
      // const arr2= [1,2,3,4];
      // const permute = arr => {
      //   const len = arr.length
      //   const curr = []
      //   const res = []
      //   const visited = {}
      //   const dfs = nth => {
      //     for (let i = 0;i<len;i++) {
      //       if (nth === len) {
      //         res.push(curr.slice())
      //         return
      //       }
      //       if (!visited[arr[i]]) {
      //         visited[arr[i]] = true
      //         curr.push(arr[i])
      //         dfs(nth+1)
      //         curr.pop()
      //         visited[arr[i]] = false
      //       }
      //     }
      //   }
      //   dfs(0)
      //   return res
      // }
      // console.log(permute(arr))
      // console.log(permute(arr2))
    </script>
    <script>
      // 栈实现队列
      // class MyQueue {
      //   constructor() {
      //     this.stack1 = [];
      //     this.stack2 = [];
      //   }

      //   push(x) {
      //     this.stack1.push(x);
      //   }

      //   pop() {
      //     if (!this.stack2.length) {
      //       while (this.stack1.length) {
      //         this.stack2.push(this.stack1.pop());
      //       }
      //     }
      //     return this.stack2.pop();
      //   }

      //   peek() {
      //     if (!this.stack2.length) {
      //       while (this.stack1.length) {
      //         this.stack2.push(this.stack1.pop());
      //       }
      //     }
      //     const len = this.stack2.length;
      //     return len && this.stack2[this.stack2.length - 1];
      //   }

      //   empty() {
      //     return this.stack1.length === 0 && this.stack2.length === 0;
      //   }
      // }
      // const queue = new MyQueue();
      // queue.push(1);
      // queue.push(2);
      // console.log(queue.peek()); // 返回 1
      // queue.pop(); // 返回 1
      // console.log(queue.empty()); // 返回 false
    </script>
    <script>
      // 有效括号
      // const leftToRight = {
      //   "(": ")",
      //   "[": "]",
      //   "{": "}",
      // };
      // const isEffect = (str) => {
      //   if (!str.length) return true;
      //   const stack = [];
      //   for (let i = 0, len = str.length; i < len; i++) {
      //     const curr = str[i];
      //     if (["(", "[", "{"].includes(curr)) {
      //       stack.push(leftToRight[curr]);
      //     } else {
      //       if (!stack.length || stack.pop() !== curr) return false;
      //     }
      //   }
      //   return !stack.length;
      // };
      // console.log(isEffect("()"));
      // console.log(isEffect("()[]{}"));
      // console.log(isEffect("(]"));
      // console.log(isEffect("([)]"));
      // console.log(isEffect("{[]}"));
    </script>
    <script>
      // 每日温度问题
      // const arr = [73, 74, 75, 71, 69, 72, 76, 73];
      // const dailyTemperatures = (arr) => {
      //   const stack = [];
      //   const len = arr.length;
      //   const result = new Array(len).fill(0);
      //   for (let i = 0; i < len; i++) {
      //     while (stack.length && arr[i] > arr[stack[stack.length - 1]]) {
      //       const top = stack.pop();
      //       result[top] = i - top;
      //     }
      //     stack.push(i);
      //   }
      //   return result;
      // };
      // console.log(dailyTemperatures(arr));
    </script>
    <script>
      // 最小栈
      // class MinStack {
      //   constructor() {
      //     this.stack = [];
      //     this.minStack = [];
      //   }
      //   push(x) {
      //     this.stack.push(x);
      //     if (
      //       this.minStack.length === 0 ||
      //       this.minStack[this.minStack.length - 1] >= x
      //     ) {
      //       this.minStack.push(x);
      //     }
      //   }
      //   pop() {
      //     if (this.stack.pop() === this.minStack[this.minStack.length - 1]) {
      //       this.minStack.pop();
      //     }
      //   }
      //   top() {
      //     if (!this.stack.length) return;
      //     return this.stack[this.stack.length - 1];
      //   }
      //   getMin() {
      //     return this.minStack[this.minStack.length - 1];
      //   }
      // }
      // const minStack = new MinStack();
      // minStack.push(-2);
      // minStack.push(0);
      // minStack.push(-3);
      // console.log(minStack.getMin());
      // minStack.pop();
      // console.log(minStack.top());
      // console.log(minStack.getMin());
    </script>
    <script>
      // 第一个flag为true的就是入环点
      // let list = createRingList([1, 2, 3, 4, 5], 2);
      // let list2 = createLinkList([1, 2, 3, 4, 5]);
      // const getConnectIndex = (head) => {
      //   while (head) {
      //     if (head.flag) {
      //       return head;
      //     } else {
      //       head.flag = true;
      //       head = head.next;
      //     }
      //   }
      //   return null;
      // };
      // console.log(getConnectIndex(list));
      // console.log(getConnectIndex(list2));
    </script>
    <script>
      // 判断链表成环
      // let list = createRingList([1, 2, 3, 4, 5], 2);
      // let list2 = createLinkList([1, 2, 3, 4, 5]);
      // 快慢指针
      // const isRing = (head) => {
      //   let slow = head;
      //   let fast = head;
      //   while (slow && fast && fast.next) {
      //     slow = slow.next;
      //     fast = fast.next.next;
      //     if (slow === fast) return true;
      //   }
      //   return false;
      // };
      // 把走过的节点 设flag为true
      // const isRing = (head) => {
      //   while (head) {
      //     if (head.flag) {
      //       return true;
      //     } else {
      //       head.flag = true;
      //       head = head.next;
      //     }
      //   }
      //   return false;
      // };
      // console.log(isRing(list));
      // console.log(isRing(list2));
    </script>
    <script>
      // 局部反转链表
      // let list = createLinkList([1, 2, 3, 4, 5]);
      // const reverseLinkListInLocal = (head, m, n) => {
      //   let prev, curr, leftHead;

      //   const dummy = new ListNode();
      //   dummy.next = head;
      //   let p = dummy;
      //   for (let i = 0; i < m - 1; i++) {
      //     p = p.next;
      //   }
      //   leftHead = p;

      //   let start = leftHead.next;
      //   prev = start;
      //   curr = prev.next;
      //   for (let i = m; i < n; i++) {
      //     let next = curr.next;
      //     curr.next = prev;
      //     prev = curr;
      //     curr = next;
      //   }
      //   leftHead.next = prev;
      //   start.next = curr;
      //   return dummy.next;
      // };
      // console.log(reverseLinkListInLocal(list, 2, 4));
    </script>
    <script>
      // 反转链表
      // let list = createLinkList([1, 2, 3, 4, 5]);
      // m1
      // const reverseLinkList = (head) => {
      //   let dummy = null;
      //   let curr = head;
      //   while (curr) {
      //     let next = curr.next;
      //     curr.next = dummy;
      //     dummy = curr;
      //     curr = next;
      //   }

      //   return dummy;
      // };
      // 迭代法
      // const reverseLinkList = (head) => {
      //   let [prev, curr] = [null, head];
      //   while (curr) {
      //     [curr.next, prev, curr] = [prev, curr, curr.next];
      //   }
      //   return prev;
      // };
      // 尾递归法
      // const reverse = (prev, curr) => {
      //   if (!curr) return prev;
      //   let tmp = curr.next;
      //   curr.next = prev;
      //   return reverse(curr, tmp);
      // };
      // const reverseLinkList = (head) => {
      //   return reverse(null, head);
      // };
      // console.log(reverseLinkList(list));
    </script>
    <script>
      // 删除链表倒数第 N 个节点
      // let list = createLinkList([1, 2, 3, 4, 5]);
      // 该实现需要遍历一遍链表,O(n)
      // const fn = (head, n) => {
      //   const dummy = new ListNode();
      //   dummy.next = head;

      //   let curr = head;
      //   let len = 0;
      //   const map = new Map();
      //   while (curr) {
      //     map.set(len, curr);
      //     curr = curr.next;
      //     len++;
      //   }
      //   console.log(len);
      //   let index = len - n;
      //   console.log(index);
      //   if (index === 0) {
      //     dummy.next = map.get(1);
      //   } else if (index === len - 1) {
      //     map.get(index - 1).next = null;
      //   } else {
      //     map.get(index - 1).next = map.get(index + 1);
      //   }

      //   return dummy.next;
      // };

      // const fn = (head, n) => {
      //   const dummy = new ListNode();
      //   dummy.next = head;

      //   let fast = dummy,
      //     slow = dummy;
      //   while (n--) {
      //     fast = fast.next;
      //   }
      //   while (fast.next) {
      //     slow = slow.next;
      //     fast = fast.next;
      //   }
      //   slow.next = slow.next.next;

      //   return dummy.next;
      // };

      // console.log(fn(list, 2));
      // console.log(fn(list, 5));
      // console.log(fn(list, 1));
    </script>
    <script>
      // 删除链表中重复的节点
      // let list = createLinkList([1, 1, 1, 2, 3, 3, 4]);
      // const deleteAllRepeat = (head) => {
      //   if (!head || !head.next) return head;

      //   const dummy = new ListNode();
      //   dummy.next = head;

      //   let curr = dummy;

      //   while (curr.next && curr.next.next) {
      //     if (curr.next.val === curr.next.next.val) {
      //       let val = curr.next.val;
      //       while (curr.next && curr.next.val === val) {
      //         curr.next = curr.next.next;
      //       }
      //     } else {
      //       curr = curr.next;
      //     }
      //   }

      //   return dummy.next;
      // };
      // console.log(deleteAllRepeat(list));
    </script>
    <script>
      // 删除有序链表中重复的元素
      // let list = createLinkList([1, 1, 1, 2, 3, 3, 4]);
      // const deleteRepeat = (head) => {
      //   let curr = head;
      //   while (curr && curr.next) {
      //     if (curr.val === curr.next.val) {
      //       curr.next = curr.next.next;
      //     } else {
      //       curr = curr.next;
      //     }
      //   }
      //   return head;
      // };
      // console.log(deleteRepeat(list));
    </script>
    <script>
      //
      // let l1 = createLinkList([1, 2, 4]);
      // let l2 = createLinkList([1, 3, 4, 5]);

      // const mergeLinkList = (l1, l2) => {
      //   let head = new ListNode();
      //   let curr = head;

      //   while (l1 && l2) {
      //     if (l1.val < l2.val) {
      //       curr.next = new ListNode(l1.val);
      //       l1 = l1.next;
      //     } else {
      //       curr.next = new ListNode(l2.val);
      //       l2 = l2.next;
      //     }
      //     curr = curr.next;
      //   }

      //   curr.next = l1 || l2;

      //   return head.next;
      // };
      // console.log(mergeLinkList(l1, l2));
    </script>
    <script>
      //
      // const fn = (str) => {
      //   const max = Math.pow(2, 31) - 1;
      //   const min = -max - 1;
      //   const reg = /\s*([-\+]?[0-9]*).*/;
      //   const groups = str.match(reg);
      //   if (groups) {
      //     return Math.min(max, Math.max(min, +groups[1]));
      //   } else {
      //     return 0;
      //   }
      // };
      // console.log(fn("42"));
      // console.log(fn("-42"));
      // console.log(fn("    -42"));
      // console.log(fn("zhangqi 1984"));
      // console.log(fn("1984zhangqi"));
      // console.log(fn("9999999999999"));
      // console.log(fn("-9999999999999"));
      // console.log(fn("-2147483649"));
    </script>
    <script>
      //
      // class WordDictionary {
      //   constructor() {
      //     this.words = {};
      //   }
      //   addWord(word) {
      //     let len = word.length;
      //     if (!this.words[len]) {
      //       this.words[len] = [];
      //     }
      //     this.words[len].push(word);
      //   }

      //   search(word) {
      //     let len = word.length;
      //     if (!this.words[len]) return false;

      //     if (!word.includes(".")) {
      //       return this.words[len].includes(word);
      //     } else {
      //       let reg = new RegExp(word);
      //       return this.words[len].some((val) => reg.test(val));
      //     }
      //   }
      // }

      // let wd = new WordDictionary();
      // wd.addWord("bad");
      // wd.addWord("dad");
      // wd.addWord("mad");
      // console.log(wd.search("pad"));
      // console.log(wd.search("..d"));
    </script>
    <script>
      // 待验证
      // const isPalid = (str) => {
      //   let len = str.length;
      //   let s = 0;
      //   let e = len - 1;

      //   while (s < e && str[s] === str[e]) {
      //     s++;
      //     e--;
      //   }

      //   const isPalidrome = (i, j) => {
      //     while (i < j) {
      //       if (str[i] !== str[j]) return false;
      //       i++;
      //       j--;
      //     }
      //     return true;
      //   };

      //   if (isPalidrome(s + 1, e)) return true;
      //   if (isPalidrome(s, e - 1)) return true;

      //   return false;
      // };
      // console.log(isPalid("abca"));
      // console.log(isPalid("abcd"));
    </script>
    <script>
      //
      // const isPalidrome = (str) => {
      //   let len = str.length;
      //   for (let i = 0; i < len / 2; i++) {
      //     if (str[i] !== str[len - 1 - i]) return false;
      //   }
      //   return true;
      // };
      // console.log(isPalidrome("abc"));
      // console.log(isPalidrome("aba"));
    </script>
    <script>
      // 三数之和 对撞指针
      // const nums = [-1, 0, 1, 2, -1, -4];
      // const target = 0;
      // const threeSum = (nums, target) => {
      //   let result = [];
      //   nums = nums.sort((a, b) => a - b);
      //   let len = nums.length;
      //   for (let i = 0; i < len - 2; i++) {
      //     let j = i + 1;
      //     let k = len - 1;

      //     if (i > 0 && nums[i] === nums[i - 1]) continue;

      //     while (j < k) {
      //       let sum = nums[i] + nums[j] + nums[k];
      //       if (sum < target) {
      //         j++;
      //         while (j < k && nums[j] === nums[j - 1]) j++;
      //       } else if (sum > target) {
      //         k--;
      //         while (j < k && nums[k] === nums[k + 1]) k--;
      //       } else {
      //         result.push([nums[i], nums[j], nums[k]]);
      //         j++;
      //         k--;
      //         while (j < k && nums[j] === nums[j - 1]) j++;
      //         while (j < k && nums[k] === nums[k + 1]) k--;
      //       }
      //     }
      //   }
      //   return result;
      // };
      // console.log(threeSum(nums, target));
    </script>
    <script>
      // 合并两个有序的数组
      // const nums1 = [1, 2, 3, 8];
      // const nums2 = [2, 5, 6];
      // const merge = (arr1, arr2) => {
      //   let i = arr1.length - 1,
      //     j = arr2.length - 1,
      //     k = arr1.length + arr2.length - 1;

      //   while (i >= 0 && j >= 0) {
      //     if (arr1[i] > arr2[j]) {
      //       arr1[k] = arr1[i];
      //       i--;
      //       k--;
      //     } else {
      //       arr1[k] = arr2[j];
      //       j--;
      //       k--;
      //     }
      //   }

      //   while (j >= 0) {
      //     arr1[k] = arr2[j];
      //     j--;
      //     k--;
      //   }
      // };
      // merge(nums1, nums2);
      // console.log(nums1);
    </script>
    <script>
      //
      // const arr = [2, 7, 11, 15];
      // const targetNum = 9;
      // const fn = (arr, targetNum) => {
      //   const map = new Map();
      //   for (let i = 0; i < arr.length; i++) {
      //     let minus = targetNum - arr[i];
      //     if (map.has(minus)) {
      //       return [map.get(minus), i];
      //     } else {
      //       map.set(arr[i], i);
      //     }
      //   }
      // };
      // console.log(fn(arr, targetNum));
    </script>
    <script>
      //
      // const coinChange = (coins, amount) => {
      //   const f = [];
      //   f[0] = 0;
      //   for (let i = 1; i <= amount; i++) {
      //     f[i] = Infinity;
      //     for (let j = 0; j < coins.length; j++) {
      //       if (i - coins[j] >= 0) {
      //         f[i] = Math.min(f[i], f[i - coins[j]] + 1);
      //       }
      //     }
      //   }
      //   if (f[amount] === Infinity) {
      //     return -1;
      //   }
      //   return f[amount];
      // };
      // console.log(coinChange([1, 2, 5], 1));
      // console.log(coinChange([1, 2, 5], 2));
      // console.log(coinChange([1, 2, 5], 5));
      // const climbStairs = (n) => {
      //   const f = [];
      //   f[1] = 1;
      //   f[2] = 2;
      //   for (let i = 3; i <= n; i++) {
      //     f[i] = f[i - 1] + f[i - 2];
      //   }
      //   return f[n];
      // };
      // for (let i = 3; i <= 10; i++) {
      //   console.log(climbStairs(i));
      // }
    </script>
    <script>
      // leetcode 面试题62
      // const lastRemaining = (n, m) => {
      //   const helper = (n, m) => {
      //     if (n === 1) return 0;
      //     return (m + helper(n - 1, m)) % n;
      //   };
      //   return helper(n, m);
      // };
      // console.log(lastRemaining(5, 3)); // 3
      // console.log(lastRemaining(10, 17)); // 2
    </script>
    <script>
      //
      // const lengthOfLIS = (nums) => {
      //   if (nums.length < 2) return nums.length;
      //   const dp = Array(nums.length).fill(1);
      //   for (let i = 1, len = nums.length; i < len; i++) {
      //     for (j = i - 1; j >= 0; j--) {
      //       if (nums[i] > nums[j]) {
      //         dp[i] = Math.max(dp[i], dp[j] + 1);
      //       }
      //     }
      //   }
      //   return Math.max.apply(Math, dp);
      // };
      // console.log(lengthOfLIS([]));
      // console.log(lengthOfLIS([1]));
      // console.log(lengthOfLIS([4, 1, 2, 3]));
      // console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])); // 4
      // console.log(lengthOfLIS([4, 10, 4, 3, 8, 9])); // 3
    </script>
    <script>
      // leetcode 47 方法需继续优化
      // const permuteUnique = (nums) => {
      //   if (nums.length === 1) return [nums];
      //   const map = {};
      //   const result = [];

      //   const helper = (curr, arr) => {
      //     if (!arr.length && !map[curr.join()]) {
      //       result.push(curr);
      //       map[curr.join()] = true;
      //       return;
      //     }
      //     arr.forEach((item, i) => {
      //       helper([...curr, item], arr.slice(0, i).concat(arr.slice(i + 1)));
      //     });
      //   };
      //   helper([], nums);

      //   return result;
      // };
      // console.log(permuteUnique([1, 1, 2]));
    </script>
    <script>
      //
      // const fac = (n) => {
      //   if (n <= 1) return 1;
      //   return n * fac(n - 1);
      // };
      // const getPermutation = (n, k) => {
      //   let result = "";
      //   let arr = Array.from({ length: n }).map((v, i) => i + 1);
      //   let len = n;
      //   while (result.length < len) {
      //     let ni = fac(n - 1);
      //     let num = ~~((k - 1) / ni);
      //     k -= num * ni;
      //     result += arr[num];
      //     arr.splice(num, 1);
      //     n--;
      //   }
      //   return result;
      // };
      // console.log(getPermutation(3, 3)); //.toBe('213')
      // console.log(getPermutation(4, 9)); //.toBe('2314')
    </script>
    <script>
      //
      // const permute = (arr) => {
      //   let result = [];

      //   let dp = (arr, res) => {
      //     if (!res.length) return result.push(arr);
      //     for (let i = 0, len = res.length; i < len; i++) {
      //       dp([...arr, res[i]], res.slice(0, i).concat(res.slice(i + 1)));
      //     }
      //   };
      //   dp([], arr);

      //   return result;
      // };
      // console.log(permute([1, 2, 3]));
      // console.log(permute([1, 2, 3, 4]));
    </script>
    <script>
      // 获取 1 ～ n 的全排列
      // const swap = (arr, i, j) => {
      //   let tmp = arr[i];
      //   arr[i] = arr[j];
      //   arr[j] = tmp;
      // };
      // const getFullPermutation = (n) => {
      //   if (n === 1) return [[1]];
      //   const nums = Array.from({ length: n }).map((v, i) => i + 1);
      //   const result = [];
      //   const backtrack = (arr, p, q) => {
      //     // 触发结束条件
      //     if (p === q) {
      //       result.push(arr.slice());
      //       return;
      //     }
      //     for (let i = p; i <= q; i++) {
      //       swap(arr, p, i);
      //       backtrack(arr, p + 1, q);
      //       swap(arr, p, i);
      //     }
      //   };
      //   backtrack(nums, 0, nums.length - 1);
      //   return result;
      // };
      // console.log(getFullPermutation(1));
      // console.log(getFullPermutation(2));
      // console.log(getFullPermutation(3));
      // console.log(getFullPermutation(4));
    </script>
    <script>
      //
      // const numRescueBoats = (people, limit) => {
      //   if (people.length === 0) return 0;
      //   let counts = new Array(limit + 1).fill(0);
      //   people.forEach((p) => counts[p]++);
      //   let k = 0;
      //   for (let i = 0; i < limit + 1; i++) {
      //     while (counts[i] > 0) {
      //       people[k++] = i;
      //       counts[i]--;
      //     }
      //   }
      //   let res = 0;
      //   let curr = 0;
      //   for (let i = people.length - 1; i >= curr; i--) {
      //     if (people[i] + people[curr] <= limit) curr++;
      //     res++;
      //   }
      //   return res;
      // };
      // console.log(numRescueBoats([1, 2], 3)); //.toBe(1)
      // console.log(numRescueBoats([1, 2, 3], 8)); //.toBe(2)
      // console.log(numRescueBoats([3, 2, 2, 1], 3)); //.toBe(3)
      // console.log(numRescueBoats([3, 5, 3, 4], 5)); //.toBe(4)
      // console.log(numRescueBoats([5, 1, 4, 2], 6)); //.toBe(2)
      // console.log(
      //   numRescueBoats(
      //     [
      //       2,
      //       49,
      //       10,
      //       7,
      //       11,
      //       41,
      //       47,
      //       2,
      //       22,
      //       6,
      //       13,
      //       12,
      //       33,
      //       18,
      //       10,
      //       26,
      //       2,
      //       6,
      //       50,
      //       10
      //     ],
      //     50
      //   )
      // ); //.toBe(11)
    </script>
    <script>
      //
      // const maxProfit = (prices, fee) => {
      //   let buy = -prices[0];
      //   let sell = 0;
      //   for (let i = 1, len = prices.length; i < len; i++) {
      //     buy = Math.max(buy, sell - prices[i]);
      //     sell = Math.max(buy + prices[i] - fee, sell);
      //   }
      //   return sell;
      // };
      // console.log(maxProfit([1, 3, 2, 8, 4, 9], 2));
    </script>
    <script>
      //
      // const maxProfit = prices => {
      //   let min = Number.MAX_SAFE_INTEGER;
      //   let max = 0;
      //   for (let i = 0, len = prices.length; i < len; i++) {
      //     if (prices[i] < min) {
      //       min = prices[i];
      //     } else if (prices[i] - min > max) {
      //       max = prices[i] - min;
      //     }
      //   }
      //   return max;
      // };
      // console.log(maxProfit([7, 2, 10, 1, 8]));
      // console.log(maxProfit([7, 1, 5, 3, 6, 4]));
      // console.log(maxProfit([7, 6, 4, 3, 1]));
    </script>
    <script>
      // 摆动序列
      // const wiggleMaxLength = nums => {
      //   if (nums.length < 2) return nums.length;
      //   let up = 1;
      //   let down = 1;
      //   for (let i = 1, len = nums.length; i < len; i++) {
      //     if (nums[i] > nums[i - 1]) {
      //       up = down + 1;
      //     }
      //     if (nums[i] < nums[i - 1]) {
      //       down = up + 1;
      //     }
      //   }
      //   return Math.max(up, down);
      // };
      // 贪心算法
      // const wiggleMaxLength = nums => {
      //   if (nums.length < 2) return nums.length;
      //   let prevDiff = nums[1] - nums[0];
      //   let count = prevDiff !== 0 ? 2 : 1;
      //   for (let i = 2, len = nums.length; i < len; i++) {
      //     let diff = nums[i] - nums[i - 1];
      //     if ((diff < 0 && prevDiff >= 0) || (diff > 0 && prevDiff <= 0)) {
      //       count++;
      //       prevDiff = diff;
      //     }
      //   }
      //   return count;
      // };
      // console.log(wiggleMaxLength([1, 7, 4, 9, 2, 5])); //.toBe(6)
      // console.log(wiggleMaxLength([1, 17, 5, 10, 13, 15, 10, 5, 16, 8])); //.toBe(7)
      // console.log(wiggleMaxLength([1, 2, 3, 4, 5, 6, 7, 8, 9])); //.toBe(2)
      // console.log(wiggleMaxLength([])); //.toBe(0)
      // console.log(wiggleMaxLength([1])); //.toBe(1)
    </script>
    <script>
      // 硬币找零3
      // const minCoinChange = (coins, amount) => {
      //   const change = [];
      //   let total = 0;
      //   for (let i = coins.length - 1; i >= 0; i--) {
      //     let coin = coins[i];
      //     while (total + coin <= amount) {
      //       change.push(coin);
      //       total += coin;
      //     }
      //   }
      //   return change;
      // };
      // console.log(minCoinChange([1, 5, 10, 25], 37));
    </script>
    <script>
      // 获取指定正整数 n 的质因数
      // const getPrimes = n => {
      //   const prime = n => {
      //     const arr = [];
      //     for (let i = 2, len = n / 2 + 1; i < len; i++) {
      //       // 能整除 并且 i是质数
      //       if (n % i === 0 && !prime(i).length) {
      //         arr.push(i);
      //       }
      //     }
      //     return arr;
      //   };
      //   return prime(n);
      // };
      // console.log(getPrimes(6));
      // console.log(getPrimes(8));
      // console.log(getPrimes(180));
    </script>
    <script>
      // 超级丑数
      // const nthSuperUglyNumber = (n, primes) => {
      //   const dp = [1];
      //   const point = new Array(primes.length).fill(0);
      //   for (let i = 1; i < n; i++) {
      //     let min = Math.min(
      //       ...primes.map((val, index) => {
      //         return dp[point[index]] * val;
      //       })
      //     );

      //     dp.push(min);
      //     for (let i = 0, len = point.length; i < len; i++) {
      //       if (min === dp[point[i]] * primes[i]) {
      //         point[i]++;
      //       }
      //     }
      //   }
      //   return dp[n - 1];
      // };
      // console.log(nthSuperUglyNumber(12, [2, 7, 13, 19]));
    </script>
    <script>
      // 鸡尾酒排序
      // const cocktailSort = arr => {
      //   let len = arr.length;
      //   for (let i = 0, l = ~~(len / 2); i < l; i++) {
      //     // 奇数轮，从左向右比较交换
      //     let isSorted = true;
      //     for (let j = i; j < len - 1 - i; j++) {
      //       if (arr[j] > arr[j + 1]) {
      //         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      //         isSorted = false;
      //       }
      //     }
      //     if (isSorted) {
      //       break;
      //     }

      //     // 偶数轮，从右向左比较交换
      //     isSorted = true;
      //     for (let j = len - 1 - i; j > i; j--) {
      //       if (arr[j] < arr[j - 1]) {
      //         [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
      //         isSorted = false;
      //       }
      //     }
      //     if (isSorted) {
      //       break;
      //     }
      //   }
      //   return arr;
      // };
      // console.log(cocktailSort([21, 6, 4, 10, 7, 1, 5, 3, 11, 9, 8]));
    </script>
    <script>
      // 冒泡排序进一步优化
      // const fn = arr => {
      //   let len = arr.length;
      //   let lastExchangeIndex = 0; // 记录最后一次交换的位置
      //   let sortBorder = len - 1; // 无序数列的边界，每次比较只需要比到这里为止

      //   for (let i = 0; i < len; i++) {
      //     let isSorted = true;
      //     for (let j = 0; j < sortBorder; j++) {
      //       if (arr[j] > arr[j + 1]) {
      //         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      //         isSorted = false;
      //         lastExchangeIndex = j;
      //       }
      //     }
      //     sortBorder = lastExchangeIndex;
      //     if (isSorted) break;
      //   }
      //   return arr;
      // };
      // console.log(fn([3, 4, 2, 1, 5, 6, 7, 8]));
    </script>
    <script>
      // 冒泡排序优化，优化后最优时间复杂度 O(n)
      // const bubbleSort = arr => {
      //   let flag = 1;
      //   for (let i = arr.length - 1, tmp; i > 0; i--) {
      //     for (let j = 0; j < i; j++) {
      //       tmp = arr[j];
      //       if (tmp > arr[j + 1]) {
      //         arr[j] = arr[j + 1];
      //         arr[j + 1] = tmp;
      //         flag = 0;
      //       }
      //     }
      //     if (flag) break;
      //   }
      //   return arr;
      // };

      // console.log(bubbleSort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 21]));
      // console.log(bubbleSort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]));
    </script>
    <script>
      // 希尔排序 2
      // const getGaps = len => {
      //   let result = [0];
      //   let start = 1;
      //   let curr = Math.pow(2, start) - 1;
      //   while (curr <= len) {
      //     result.push(curr);
      //     curr = Math.pow(2, ++start) - 1;
      //   }
      //   return result;
      // };

      // const shellSort = arr => {
      //   let len = arr.length;
      //   let gaps = getGaps(len / 2);
      //   let gap = gaps.pop();

      //   while (gap !== 0) {
      //     for (let i = gap; i < len; i++) {
      //       let cur = arr[i];
      //       let j = i - gap;
      //       for (; j >= 0 && cur < arr[j]; j -= gap) {
      //         arr[j + gap] = arr[j];
      //       }
      //       arr[j + gap] = cur;
      //     }
      //     gap = gaps.pop();
      //   }

      //   return arr;
      // };
      // console.log(shellSort([21, 6, 4, 10, 7, 1, 5, 3, 11, 9, 8, 2]));
    </script>
    <script>
      // 希尔排序
      // const shellSort = arr => {
      //   let len = arr.length;
      //   let gap = ~~(len / 2);

      //   while (gap >= 1) {
      //     for (let i = gap; i < len; i++) {
      //       let cur = i;
      //       let prev = i - gap;
      //       while (prev >= 0 && arr[cur] < arr[prev]) {
      //         [arr[cur], arr[prev]] = [arr[prev], arr[cur]];
      //         cur = prev;
      //         prev -= gap;
      //       }
      //     }
      //     gap = ~~(gap / 2);
      //   }

      //   return arr;
      // };
      // console.log(shellSort([21, 6, 4, 10, 7, 1, 5, 3, 11, 9, 8, 2]));
    </script>
    <script>
      // 堆排序
      // const maxHeapify = (arr, index, heapSize) => {
      //   let iMax = index;
      //   let iLeft = 2 * index + 1;
      //   let iRight = 2 * (index + 1);

      //   // 左节点是否比当前结点大
      //   if (iLeft < heapSize && arr[index] < arr[iLeft]) {
      //     iMax = iLeft;
      //   }

      //   // 右节点是否比当前结点大
      //   if (iRight < heapSize && arr[iMax] < arr[iRight]) {
      //     iMax = iRight;
      //   }

      //   // 如果当前节点不是三者中最大的
      //   if (iMax !== index) {
      //     [arr[iMax], arr[index]] = [arr[index], arr[iMax]];
      //     maxHeapify(arr, iMax, heapSize);
      //   }
      // };
      // const buildMaxHeap = (arr, heapSize) => {
      //   // 找到最后一个非叶子结点
      //   let iParent = ~~(heapSize / 2 - 1);
      //   // 调整至大顶堆
      //   for (let i = iParent; i >= 0; i--) {
      //     maxHeapify(arr, i, heapSize);
      //   }
      // };
      // const heapSort = arr => {
      //   let heapSize = arr.length;

      //   buildMaxHeap(arr, heapSize);

      //   // 将堆顶元素和末尾元素互换，使末尾元素最大，继续调整堆
      //   for (let i = heapSize - 1; i > 0; i--) {
      //     [arr[0], arr[i]] = [arr[i], arr[0]];
      //     maxHeapify(arr, 0, i);
      //   }

      //   return arr;
      // };
      // console.log(heapSort([3, 4, 10, 2, 1, 5, 6, 9, 8, 7]));
    </script>
    <script>
      // 基数排序 + 桶排序
      // const bucketSortForRadix = (arr, significantDigit, radixBase) => {
      //   let buckets = [];
      //   let aux = [];
      //   let len = arr.length;
      //   // 初始化桶
      //   for (let i = 0; i < radixBase; i++) {
      //     buckets[i] = [];
      //   }
      //   for (let i = 0; i < len; i++) {
      //     let bucketIndex = ~~(arr[i] / significantDigit) % radixBase;
      //     buckets[bucketIndex].push(arr[i]);
      //   }
      //   for (let i = 0; i < radixBase; i++) {
      //     aux.push(...buckets[i]);
      //   }
      //   for (let i = 0; i < len; i++) {
      //     arr[i] = aux[i];
      //   }
      //   return arr;
      // };
      // const radixSort = arr => {
      //   if (arr.length < 2) return arr;

      //   let significantDigit = 1; // 有效位，先基于个位数
      //   let radixBase = 10; // 排序十进制数，基数为 10,使用 10 个桶分布元素

      //   // 找出最大值
      //   let maxValue = arr[0];
      //   for (let i = 1, len = arr.length; i < len; i++) {
      //     if (arr[i] > maxValue) {
      //       maxValue = arr[i];
      //     }
      //   }
      //   // 从个位开始排序
      //   while (maxValue / significantDigit >= 1) {
      //     arr = bucketSortForRadix(arr, significantDigit, radixBase);
      //     significantDigit *= radixBase;
      //   }

      //   return arr;
      // };
      // console.log(radixSort([3, 4, 2, 100, 1, 35, 6, 9, 8, 7]));
    </script>
    <script>
      // 基数排序
      // const countingSortForRadix = (arr, radixBase, significantDigit) => {
      //   let bucketIndex = 0;
      //   let buckets = new Array(radixBase).fill(0);
      //   let aux = [];
      //   let len = arr.length;

      //   for (let i = 0; i < len; i++) {
      //     bucketIndex = ~~(arr[i] / significantDigit) % radixBase;
      //     buckets[bucketIndex]++;
      //   }

      //   for (let i = 1; i < radixBase; i++) {
      //     buckets[i] += buckets[i - 1];
      //   }

      //   for (let i = len - 1; i >= 0; i--) {
      //     bucketIndex = ~~(arr[i] / significantDigit) % radixBase;
      //     aux[--buckets[bucketIndex]] = arr[i];
      //   }

      //   for (let i = 0; i < len; i++) {
      //     arr[i] = aux[i];
      //   }
      //   return arr;
      // };

      // const radixSort = (arr, radixBase = 10) => {
      //   if (arr.length < 2) return arr;
      //   let maxValue = arr[0];
      //   for (let i = 1, len = arr.length; i < len; i++) {
      //     if (arr[i] > maxValue) {
      //       maxValue = arr[i];
      //     }
      //   }

      //   let significantDigit = 1;
      //   while (maxValue / significantDigit >= 1) {
      //     arr = countingSortForRadix(arr, radixBase, significantDigit);
      //     significantDigit *= radixBase;
      //   }
      //   return arr;
      // };
      // console.log(radixSort([3, 4, 2, 100, 1, 35, 6, 9, 8, 7, 5]));
    </script>
    <script>
      // 桶排序 2
      // const insertSort = arr => {
      //   for (let i = 1, len = arr.length, tmp; i < len; i++) {
      //     let j = i;
      //     tmp = arr[i];
      //     while (j > 0 && arr[j - 1] > tmp) {
      //       arr[j] = arr[j - 1];
      //       j--;
      //     }
      //     arr[j] = tmp;
      //   }
      //   return arr;
      // };
      // const bucketSort = (arr, bucketCount) => {
      //   if (arr.length < 2) return arr;

      //   let len = arr.length;
      //   let min = arr[0];
      //   let max = arr[0];
      //   let buckets = [];
      //   let result = [];

      //   for (let i = 1; i < len; i++) {
      //     if (arr[i] > max) {
      //       max = arr[i];
      //     } else if (arr[i] < min) {
      //       min = arr[i];
      //     }
      //   }
      //   // 求出每一个桶的数值范围
      //   let space = (max - min + 1) / bucketCount;
      //   for (let i = 0; i < len; i++) {
      //     // 找到相应的桶排序
      //     let index = ~~((arr[i] - min) / space);
      //     if (buckets[index]) {
      //       buckets[index].push(arr[i]);
      //     } else {
      //       buckets[index] = [arr[i]];
      //     }
      //   }

      //   buckets.forEach(bucket => result.push(...insertSort(bucket)));
      //   return result;
      // };
      // console.log(bucketSort([3, 4, 2, 1, 5, 6, 9, 8, 7], 4));
    </script>
    <script>
      // 桶排序
      // 使用插入排序排序桶中的元素
      // const insertSort = arr => {
      //   for (let i = 1, len = arr.length, tmp; i < len; i++) {
      //     let j = i;
      //     tmp = arr[i];
      //     while (j > 0 && arr[j - 1] > tmp) {
      //       arr[j] = arr[j - 1];
      //       j--;
      //     }
      //     arr[j] = tmp;
      //   }
      //   return arr;
      // };
      // const sortBuckets = buckets => {
      //   const sortArr = [];
      //   for (let i = 0, len = buckets.length; i < len; i++) {
      //     let bucket = buckets[i];
      //     if (bucket) {
      //       insertSort(bucket);
      //       sortArr.push(...bucket);
      //     }
      //   }
      //   return sortArr;
      // };
      // // bucketSize 应为桶中的元素个数，bucketCount 为桶的个数
      // const createBuckets = (arr, bucketSize) => {
      //   // 找到最大值和最小值
      //   let maxValue = arr[0];
      //   let minValue = arr[0];
      //   for (let i = 1, len = arr.length; i < len; i++) {
      //     if (arr[i] > maxValue) {
      //       maxValue = arr[i];
      //     } else if (arr[i] < minValue) {
      //       minValue = arr[i];
      //     }
      //   }
      //   // 计算需要多少个桶
      //   const bucketCount = ~~((maxValue - minValue) / bucketSize) + 1;
      //   // 创建桶
      //   const buckets = [];
      //   for (let i = 0; i < bucketCount; i++) {
      //     buckets[i] = [];
      //   }
      //   // 将元素分布到不同的桶中
      //   // 0: [3,4,2,1,5]
      //   // 1: [6,9,8,7]
      //   for (let i = 0, len = arr.length; i < len; i++) {
      //     const bucketIndex = ~~((arr[i] - minValue) / bucketSize);
      //     buckets[bucketIndex].push(arr[i]);
      //   }
      //   console.log(buckets);
      //   return buckets;
      // };
      // const bucketSort = (arr, bucketSize = 5) => {
      //   if (arr.length < 2) return arr;
      //   const buckets = createBuckets(arr, bucketSize);
      //   return sortBuckets(buckets);
      // };
      // console.log(bucketSort([3, 4, 2, 1, 5, 6, 9, 8, 7], 2));
      // console.log(
      //   bucketSort(
      //     [
      //       63,
      //       157,
      //       189,
      //       51,
      //       101,
      //       47,
      //       141,
      //       121,
      //       157,
      //       156,
      //       194,
      //       117,
      //       98,
      //       139,
      //       67,
      //       133,
      //       181,
      //       13,
      //       28,
      //       109
      //     ],
      //     5
      //   )
      // );
    </script>
    <script>
      // 计数排序 2 稳定排序
      // const countingSort = arr => {
      //   if (arr.length < 1) return arr;

      //   let len = arr.length;
      //   let max = arr[0];
      //   let min = arr[0];
      //   for (let i = 1; i < len; i++) {
      //     max = Math.max(arr[i], max);
      //     min = Math.min(arr[i], min);
      //   }
      //   let countArr = new Array(max - min + 1).fill(0);
      //   let result = [];

      //   for (let i = 0; i < len; i++) {
      //     countArr[arr[i] - min]++;
      //   }

      //   // 存储当前元素值的最后位置
      //   // 最小的值肯定在第一位，第二小在第二位，以此类推
      //   for (let i = 1, l = countArr.length; i < l; i++) {
      //     countArr[i] += countArr[i - 1];
      //   }

      //   // 倒序遍历数组
      //   // 对于两个相同的值，[3,5,5,4]
      //   // 排序后， 后面的5在第4个位置，也就是索引为3，前面的5在第3个位置，索引为2，这样实现了稳定排序
      //   for (let i = len - 1; i >= 0; i--) {
      //     result[--countArr[arr[i] - min]] = arr[i];
      //   }

      //   return result;
      // };
      // console.log(countingSort([3, 4, 2, 1, 46, 5, 6, 9, 8, 7]));
    </script>
    <script>
      // 计数排序
      // const findMaxValue = arr => {
      //   let max = arr[0];
      //   for (let i = 1, len = arr.length; i < len; i++) {
      //     if (arr[i] > max) {
      //       max = arr[i];
      //     }
      //   }
      //   return max;
      // };
      // const countingSort = arr => {
      //   if (arr.length < 2) return arr;

      //   let maxValue = findMaxValue(arr);
      //   let countArr = new Array(maxValue + 1);
      //   arr.forEach(val => {
      //     if (!countArr[val]) {
      //       countArr[val] = 0;
      //     }
      //     countArr[val]++;
      //   });

      //   for (let i = 0, j = 0, l = countArr.length; i < l; i++) {
      //     while (countArr[i]--) arr[j++] = i;
      //   }

      //   return arr;
      // };
      // console.log(countingSort([1, 2, 3, 4, 5, 6, 9, 8, 7]));
    </script>
    <script>
      // 快排 2
      // [ 1, 2, 3, 4, 5, 6, 9, 8, 7 ]
      // const partition = (arr, left, right) => {
      //   const pivot = arr[~~((left + right) / 2)];
      //   let i = left;
      //   let j = right;

      //   while (i <= j) {
      //     while (arr[i] < pivot) {
      //       i++;
      //     }
      //     while (arr[j] > pivot) {
      //       j--;
      //     }
      //     if (i <= j) {
      //       [arr[i], arr[j]] = [arr[j], arr[i]];
      //       i++;
      //       j--;
      //     }
      //   }
      //   return i;
      // };
      // const quick = (arr, left, right) => {
      //   if (arr.length > 1) {
      //     let index = partition(arr, left, right);
      //     if (left < index - 1) {
      //       quick(arr, left, index - 1);
      //     }
      //     if (index < right) {
      //       quick(arr, index, right);
      //     }
      //   }
      //   return arr;
      // };
      // const quickSort = arr => {
      //   return quick(arr, 0, arr.length - 1);
      // };
      // console.log(quickSort([3, 6, 4, 5, 1, 2, 9, 8, 7]));
    </script>
    <script>
      // 快排 1
      // const quickSort = arr => {
      //   if (arr.length < 2) return arr;
      //   let len = arr.length;
      //   let mid = ~~(len / 2);
      //   let pivot = arr[mid];
      //   let left = [];
      //   let right = [];
      //   for (let i = 0; i < len; i++) {
      //     if (i === mid) continue;
      //     let curr = arr[i];
      //     if (curr <= pivot) {
      //       left.push(curr);
      //     } else {
      //       right.push(curr);
      //     }
      //   }
      //   return quickSort(left).concat(pivot, quickSort(right));
      // };
      // console.log(quickSort([3, 6, 4, 5, 1, 2, 9, 8, 7]));
    </script>
    <script>
      // 归并
      // const mergeSort = arr => {
      //   const merge = (left, right) => {
      //     if (left[left.length - 1] <= right[0]) {
      //       return left.concat(right);
      //     }

      //     let result = [];
      //     while (left.length && right.length) {
      //       let l = left[0];
      //       let r = right[0];
      //       if (l < r) {
      //         result.push(left.shift());
      //       } else {
      //         result.push(right.shift());
      //       }
      //     }

      //     if (left.length) result.push(...left);
      //     if (right.length) result.push(...right);

      //     return result;
      //   };
      //   const mergeSort = arr => {
      //     let len = arr.length;
      //     if (len === 1) {
      //       return arr;
      //     }
      //     let mid = ~~(len / 2);
      //     let res = merge(
      //       mergeSort(arr.slice(0, mid)),
      //       mergeSort(arr.slice(mid))
      //     );
      //     return res;
      //   };
      //   return mergeSort(arr);
      // };
      // console.log(mergeSort([3, 6, 4, 5, 1, 2, 9, 8, 7]));
    </script>
    <script>
      // 插入
      // const insertSort = arr => {
      //   for (let i = 1, len = arr.length, tmp; i < len; i++) {
      //     let j = i;
      //     tmp = arr[i];
      //     while (j > 0 && arr[j - 1] > tmp) {
      //       arr[j] = arr[j - 1];
      //       j--;
      //     }
      //     arr[j] = tmp;
      //   }
      //   return arr;
      // };
      // console.log(insertSort([3, 6, 4, 5, 1, 2, 9, 8, 7]));
    </script>
    <script>
      // 选择
      // const selectSort = arr => {
      //   for (let i = 0, len = arr.length, minIndex; i < len - 1; i++) {
      //     minIndex = i;
      //     for (let j = i + 1; j < len; j++) {
      //       if (arr[minIndex] > arr[j]) {
      //         minIndex = j;
      //       }
      //     }
      //     if (i !== minIndex) {
      //       [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
      //     }
      //   }
      //   return arr;
      // };
      // console.log(selectSort([3, 2, 4, 5, 1, 6, 9, 8, 7]));
    </script>
    <script>
      // 冒泡
      // const bubbleSort = arr => {
      //   for (let i = arr.length, tmp; i > 0; i--) {
      //     for (let j = 0; j < i; j++) {
      //       tmp = arr[j];
      //       if (tmp > arr[j + 1]) {
      //         arr[j] = arr[j + 1];
      //         arr[j + 1] = tmp;
      //       }
      //     }
      //   }
      //   return arr;
      // };
      // console.log(bubbleSort([3, 2, 4, 5, 1]));
    </script>
    <script>
      //
      // class TreeNode {
      //   constructor(val) {
      //     this.val = val;
      //     this.left = this.right = null;
      //   }
      // }
      // let tree = {
      //   val: 5,
      //   left: { val: 1, left: null, right: null },
      //   right: {
      //     val: 4,
      //     left: { val: 3, left: null, right: null },
      //     right: { val: 6, left: null, right: null }
      //   }
      // };
      // let tree2 = {
      //   val: 2,
      //   left: { val: 1, left: null, right: null },
      //   right: { val: 3, left: null, right: null }
      // };
      // let tree3 = {
      //   val: 1,
      //   left: { val: 1, left: null, right: null },
      //   right: null
      // };
      // let tree4 = {
      //   val: 0,
      //   left: null,
      //   right: null
      // };
      // const isValidBST = root => {
      //   const helper = (node, min, max) => {
      //     if (node === null) return true;
      //     if (min != null && node.val <= min) return false;
      //     if (max != null && node.val >= max) return false;

      //     return (
      //       helper(node.left, min, node.val) &&
      //       helper(node.right, node.val, max)
      //     );
      //   };
      //   return helper(root);
      // };
      // console.log(isValidBST(tree));
      // console.log(isValidBST(tree2));
      // console.log(isValidBST(tree3));
      // console.log(isValidBST(tree4));
    </script>
    <script>
      //
      // class Node {
      //   constructor(key) {
      //     this.key = key;
      //     this.left = null;
      //     this.right = null;
      //   }
      // }
      // const insertNode = (root, node) => {
      //   if (node.key < root.key) {
      //     if (root.left === null) {
      //       root.left = node;
      //     } else {
      //       insertNode(root.left, node);
      //     }
      //   } else {
      //     if (root.right === null) {
      //       root.right = node;
      //     } else {
      //       insertNode(root.right, node);
      //     }
      //   }
      // };
      // const inOrderTraverse = (node, callback) => {
      //   if (node !== null) {
      //     inOrderTraverse(node.left, callback);
      //     callback(node.key);
      //     inOrderTraverse(node.right, callback);
      //   }
      // };
      // const preOrderTraverse = (node, callback) => {
      //   if (node !== null) {
      //     callback(node.key);
      //     preOrderTraverse(node.left, callback);
      //     preOrderTraverse(node.right, callback);
      //   }
      // };
      // const postOrderTraverse = (node, callback) => {
      //   if (node !== null) {
      //     postOrderTraverse(node.left, callback);
      //     postOrderTraverse(node.right, callback);
      //     callback(node.key);
      //   }
      // };
      // const minNode = node => {
      //   if (node) {
      //     while (node && node.left !== null) {
      //       node = node.left;
      //     }
      //     return node.key;
      //   }
      // };
      // const maxNode = node => {
      //   if (node) {
      //     while (node && node.right !== null) {
      //       node = node.right;
      //     }
      //     return node.key;
      //   }
      // };
      // const findMinNode = node => {
      //   if (node) {
      //     while (node && node.left !== null) {
      //       node = node.left;
      //     }
      //     return node;
      //   }
      // };
      // const searchNode = (node, key) => {
      //   if (node === null) return false;
      //   if (key < node.key) {
      //     return searchNode(node.left, key);
      //   } else if (key > node.key) {
      //     return searchNode(node.right, key);
      //   } else {
      //     return true;
      //   }
      // };
      // const removeNode = (node, key) => {
      //   if (node === null) {
      //     return null;
      //   }
      //   if (key < node.key) {
      //     node.left = removeNode(node.left, key);
      //     return node;
      //   } else if (key > node.key) {
      //     node.right = removeNode(node.right, key);
      //     return node;
      //   } else {
      //     // 叶子结点
      //     if (node.left === null && node.right === null) {
      //       node = null;
      //       return node;
      //     }
      //     // 只有一个子节点
      //     if (node.left === null) {
      //       node = node.right;
      //       return node;
      //     } else if (node.right === null) {
      //       node = node.left;
      //       return node;
      //     }
      //     // 有两个子节点
      //     // 先找到右侧节点的最小值，将key值赋给node，等于删除了原节点
      //     let minNode = findMinNode(node.right);
      //     node.key = minNode.key;
      //     node.right = removeNode(node.right, minNode.key);
      //     return node;
      //   }
      // };

      // class BinaryTree {
      //   constructor() {
      //     this.root = null;
      //   }

      //   insert(key) {
      //     let newNode = new Node(key);

      //     if (this.root === null) {
      //       this.root = newNode;
      //     } else {
      //       insertNode(this.root, newNode);
      //     }
      //   }

      //   search(key) {
      //     return searchNode(this.root, key);
      //   }
      //   // 中序遍历
      //   inOrderTraverse(callback) {
      //     inOrderTraverse(this.root, callback);
      //   }
      //   // 先序遍历
      //   preOrderTraverse(callback) {
      //     preOrderTraverse(this.root, callback);
      //   }
      //   // 后续便利
      //   postOrderTraverse(callback) {
      //     postOrderTraverse(this.root, callback);
      //   }
      //   min() {
      //     return minNode(this.root);
      //   }
      //   max() {
      //     return maxNode(this.root);
      //   }
      //   remove(key) {
      //     this.root = removeNode(this.root, key);
      //   }
      // }

      // let tree = new BinaryTree();
      // tree.insert(11);
      // tree.insert(7);
      // tree.insert(15);
      // tree.insert(5);
      // tree.insert(3);
      // tree.insert(9);
      // tree.insert(8);
      // tree.insert(10);
      // tree.insert(13);
      // tree.insert(12);
      // tree.insert(14);
      // tree.insert(20);
      // tree.insert(18);
      // tree.insert(25);
      // tree.insert(6);

      // console.log(tree);
      // tree.inOrderTraverse(node => console.log(node));
      // tree.preOrderTraverse(node => console.log(node));
      // tree.postOrderTraverse(node => console.log(node));
      // console.log(tree.min());
      // console.log(tree.max());
      // console.log(tree.search(6));
    </script>
    <script>
      //
      // let param = "q=URLUtils.searchParams&topic=api";
      // let p = new URLSearchParams(param);
      // for (let key of p) {
      //   console.log(key);
      // }
    </script>
    <script>
      // console.log(":", encodeURIComponent(":"));
      // console.log(";", encodeURIComponent(";"));
      // console.log("/", encodeURIComponent("/"));
      // console.log("?", encodeURIComponent("?"));
      // console.log("@", encodeURIComponent("@"));
      // console.log("&", encodeURIComponent("&"));
      // console.log("=", encodeURIComponent("="));
      // console.log("+", encodeURIComponent("+"));
      // console.log("$", encodeURIComponent("$"));
      // console.log(",", encodeURIComponent(","));
      // console.log("#", encodeURIComponent("#"));
      // console.log("[", encodeURIComponent("["));
      // console.log("]", encodeURIComponent("]"));
      // console.log("{", encodeURIComponent("{"));
      // console.log("}", encodeURIComponent("}"));
      // console.log(" ", encodeURIComponent(" "));
    </script>
    <script>
      // 集合覆盖问题（贪婪算法）
      // let states = ["mt", "wa", "or", "id", "nv", "ut", "ca", "az"];
      // let stations = {};
      // stations["kone"] = ["id", "nv", "ut"];
      // stations["ktwo"] = ["wa", "id", "mt"];
      // stations["kthree"] = ["or", "nv", "ca"];
      // stations["kfour"] = ["nv", "ut"];
      // stations["kfive"] = ["ca", "az"];
      // let final = [];
      // let hasCompared = {};
      // while (states.length) {
      //   let bestStation = "";
      //   let stateCovered = [];
      //   for (let key in stations) {
      //     if (hasCompared[key]) continue;
      //     let covered = states.filter(item => stations[key].includes(item));
      //     if (covered.length > stateCovered.length) {
      //       bestStation = key;
      //       stateCovered = covered;
      //       hasCompared[key] = true;
      //     }
      //   }
      //   final.push(bestStation);
      //   states = states.filter(item => !stateCovered.includes(item));
      // }
      // console.log(final);
    </script>
    <script>
      // 图，广度优先搜索
      // let graph = {};
      // graph["you"] = ["baiyang", "zhaojinge", "lixiang"];
      // graph["baiyang"] = ["shenxia"];
      // graph["zhaojinge"] = ["zhangqi"];
      // graph["lixiang"] = ["pipi", "dalu"];
      // graph["shenxia"] = [];
      // graph["zhangqi"] = ["zhaojinge"];
      // graph["pipi"] = ["dalu"];
      // graph["dalu"] = ["pipi"];

      // let find = (graph, target) => {
      //   let arr = graph["you"];
      //   let map = {};
      //   while (arr.length) {
      //     let cur = arr.shift();
      //     if (!map[cur]) {
      //       if (cur === target) {
      //         return true;
      //       } else {
      //         if (graph[cur]) {
      //           arr.push(...graph[cur]);
      //         }
      //         map[cur] = true;
      //       }
      //     }
      //   }
      //   return false;
      // };
      // console.log(find(graph, ""));
    </script>
    <script>
      // let ride = (n1, n2) => {
      //   let res = [];
      //   let carry = 0;
      //   for (let i = n2.length - 1; i >= 0; i--) {
      //     let cur = +n2[i];
      //     let m = n1 * cur + carry;
      //     if (m > 9) {
      //       carry = Math.floor(m / 10);
      //       res.unshift(m % 10);
      //     } else {
      //       res.unshift(m);
      //       carry = 0;
      //     }
      //   }
      //   if (carry) {
      //     res.unshift(carry);
      //   }
      //   return res.join("");
      // };
      // let plus = arr => {
      //   let l1 = arr[0].length;
      //   let l2 = arr.length;
      //   let res = [];
      //   let carry = 0;
      //   for (let i = l1 - 1; i >= 0; i--) {
      //     let sum = carry;
      //     for (let j = 0; j < l2; j++) {
      //       sum += +arr[j][i];
      //     }
      //     if (sum > 9) {
      //       carry = Math.floor(sum / 10);
      //       res.unshift(sum % 10);
      //     } else {
      //       res.unshift(sum);
      //       carry = 0;
      //     }
      //   }
      //   if (carry) {
      //     res.unshift(carry);
      //   }
      //   return res.join("").replace(/^0*/, "");
      // };
      // let fn = (n1, n2) => {
      //   if (n1 === "0" || n2 === "0") return "0";
      //   let result = [];
      //   let len = n2.length;
      //   let max = n1.length + len;
      //   for (let i = len - 1; i >= 0; i--) {
      //     let cur = +n2[i];
      //     let m = ride(cur, n1);
      //     m = m.padEnd(m.length + len - i - 1, "0");
      //     m = m.padStart(max, "0");
      //     result.push(m);
      //   }
      //   return plus(result);
      // };
      // console.log(fn("9", "9"));
      // console.log(fn("123", "456"));
      // console.log(fn("123893475346587340", "4567238946238974320"));
    </script>
    <script>
      // let fn = (arr, target) => {
      //   let findLeft = (arr, target) => {
      //     if (!arr.length) return -1;
      //     let left = 0;
      //     let right = arr.length;
      //     let mid;

      //     while (left < right) {
      //       mid = Math.floor((left + right) / 2);
      //       if (arr[mid] === target) {
      //         right = mid;
      //       } else if (arr[mid] < target) {
      //         left = mid + 1;
      //       } else if (arr[mid] > target) {
      //         right = mid;
      //       }
      //     }
      //     if (left === arr.length) return -1;
      //     return arr[left] === target ? left : -1;
      //   };
      //   let findRight = (arr, target) => {
      //     if (!arr.length) return -1;
      //     let left = 0;
      //     let right = arr.length;
      //     let mid;

      //     while (left < right) {
      //       mid = Math.floor((left + right) / 2);
      //       if (arr[mid] === target) {
      //         left = mid + 1;
      //       } else if (arr[mid] < target) {
      //         left = mid + 1;
      //       } else if (arr[mid] > target) {
      //         right = mid;
      //       }
      //     }
      //     if (left === 0) return -1;
      //     return arr[left - 1] === target ? left - 1 : -1;
      //   };
      //   return [findLeft(arr, target), findRight(arr, target)];
      // };
      // console.log(fn([1, 2, 2, 2, 3], 2));
    </script>
    <script>
      // let fn = arr => {
      //   let rows = {};
      //   let columns = {};
      //   let boxes = {};
      //   for (let i = 0, il = arr[0].length; i < il; i++) {
      //     for (let j = 0, jl = arr.length; j < jl; j++) {
      //       let rowIndex = j;
      //       let columnIndex = i;
      //       let boxIndex = Math.floor(i / 3) + Math.floor(j / 3) * 3;

      //       let cur = arr[j][i];
      //       if (cur === ".") continue;

      //       if (!rows[rowIndex]) {
      //         rows[rowIndex] = {};
      //       }
      //       if (rows[rowIndex][cur]) {
      //         return false;
      //       } else {
      //         rows[rowIndex][cur] = true;
      //       }

      //       if (!columns[columnIndex]) {
      //         columns[columnIndex] = {};
      //       }
      //       if (columns[columnIndex][cur]) {
      //         return false;
      //       } else {
      //         columns[columnIndex][cur] = true;
      //       }

      //       if (!boxes[boxIndex]) {
      //         boxes[boxIndex] = {};
      //       }
      //       if (boxes[boxIndex][cur]) {
      //         return false;
      //       } else {
      //         boxes[boxIndex][cur] = true;
      //       }
      //     }
      //   }
      //   return true;
      // };
      // console.log(
      //   fn([
      //     [".", ".", ".", ".", "5", ".", ".", "1", "."],
      //     [".", "4", ".", "3", ".", ".", ".", ".", "."],
      //     [".", ".", ".", ".", ".", "3", ".", ".", "1"],
      //     ["8", ".", ".", ".", ".", ".", ".", "2", "."],
      //     [".", ".", "2", ".", "7", ".", ".", ".", "."],
      //     [".", "1", "5", ".", ".", ".", ".", ".", "."],
      //     [".", ".", ".", ".", ".", "2", ".", ".", "."],
      //     [".", "2", ".", "9", ".", ".", ".", ".", "."],
      //     [".", ".", "4", ".", ".", ".", ".", ".", "."]
      //   ])
      // );
      // console.log(
      //   fn([
      //     [".", ".", ".", ".", "5", ".", ".", "1", "."],
      //     [".", "4", ".", "3", ".", ".", ".", ".", "."],
      //     [".", ".", ".", ".", ".", "3", ".", ".", "1"],
      //     ["8", ".", ".", ".", ".", ".", ".", "2", "."],
      //     [".", ".", "2", ".", "7", ".", ".", ".", "."],
      //     [".", "1", "5", ".", ".", ".", ".", ".", "."],
      //     [".", ".", ".", ".", ".", "2", ".", ".", "."],
      //     [".", "2", ".", "9", ".", ".", ".", ".", "."],
      //     [".", ".", "4", ".", ".", ".", ".", ".", "."]
      //   ])
      // );
    </script>
    <script>
      //
      // let fn = heights => {
      //   let total = 0;
      //   let arr = [].concat(heights);
      //   arr.sort((a, b) => a - b);
      //   arr.forEach((item, index) => {
      //     if (item !== heights[index]) total++;
      //   });
      //   return total;
      // };
      // console.log(fn([1, 1, 4, 2, 1, 3]));
    </script>
    <script>
      // 括号生成
      // let fn = n => {
      //   let res = [];
      //   let helper = (ps, l, r) => {
      //     if (l === n && r === n) {
      //       res.push(ps);
      //       return;
      //     }
      //     if (l < n) {
      //       helper(ps + "(", l + 1, r);
      //     }
      //     if (l > r) {
      //       helper(ps + ")", l, r + 1);
      //     }
      //   };
      //   helper("", 0, 0);
      //   return res;
      // };
      // console.log(JSON.stringify(fn(3)));
    </script>
    <script>
      //
      // let fn = str => {
      //   let len = str.length;
      //   let dp = Array(len);
      //   let max = -1;
      //   let s = "";
      //   for (let k = 0; k < len; k++) {
      //     // k为所遍历的子串长度 - 1，即左下标到右下标的距离
      //     for (let i = 0; i < len - k; i++) {
      //       let j = i + k;
      //       // i为子串开始的左下标，j为子串开始的右下标
      //       if (k === 0) {
      //         // 当子串长度为1时，必定是回文
      //         dp[i][j] = true;
      //       } else if (k <= 2) {
      //         // 当子串长度为2时，两字符相同则符合回文，长度为3，首位字符相同则符合回文
      //         dp[i][j] = s[i] === s[j];
      //       } else {
      //         // 当子串长度超过3，取决于去掉头尾之后的子串是否回文并且首位字符是否相同
      //         dp[i][j] = dp[i + 1][j - 1] && s[i] === s[j];
      //       }

      //       if (dp[i][j] && k > max) {
      //         max = k;
      //         s = str.substring(i, j + 1);
      //       }
      //     }
      //   }
      //   return s;
      // };
      // let str =
      //   "civilwartestingwhetherthatnaptionoranynartionsoconceivedandsodedicatedcanlongendureWeareqmetonagreatbattlefiemldoftzhatwarWehavecometodedicpateaportionofthatfieldasafinalrestingplaceforthosewhoheregavetheirlivesthatthatnationmightliveItisaltogetherfangandproperthatweshoulddothisButinalargersensewecannotdedicatewecannotconsecratewecannothallowthisgroundThebravelmenlivinganddeadwhostruggledherehaveconsecrateditfaraboveourpoorponwertoaddordetractTgheworldadswfilllittlenotlenorlongrememberwhatwesayherebutitcanneverforgetwhattheydidhereItisforusthelivingrathertobededicatedheretotheulnfinishedworkwhichtheywhofoughtherehavethusfarsonoblyadvancedItisratherforustobeherededicatedtothegreattdafskremainingbeforeusthatfromthesehonoreddeadwetakeincreaseddevotiontothatcauseforwhichtheygavethelastpfullmeasureofdevotionthatweherehighlyresolvethatthesedeadshallnothavediedinvainthatthisnationunsderGodshallhaveanewbirthoffreedomandthatgovernmentofthepeoplebythepeopleforthepeopleshallnotperishfromtheearth";
      // console.log(fn(str));
    </script>
    <script>
      // 最大矩形
      // let arr = [
      //   ["1", "0", "1", "0", "0"],
      //   ["1", "0", "1", "1", "1"],
      //   ["1", "1", "1", "1", "1"],
      //   ["1", "0", "0", "1", "0"]
      // ];
      // let arr = [
      //   ["0", "1", "1", "1", "0", "0", "1", "1", "1", "1", "0", "0"],
      //   ["0", "0", "1", "1", "0", "1", "1", "1", "1", "0", "0", "1"],
      //   ["0", "1", "1", "1", "0", "0", "1", "1", "1", "1", "1", "1"],
      //   ["0", "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
      //   ["0", "1", "1", "0", "0", "0", "1", "1", "1", "1", "1", "1"]
      // ];
      // console.table(arr);
      // let fn = arr => {
      //   let result = [];
      //   let reg = /1{2,}/g;
      //   arr = arr.map(item => {
      //     let str = item.join("");
      //     let r = reg.exec(str);
      //     let rs = [];
      //     while (r) {
      //       rs.push([r.index, r.index + r[0].length - 1]);
      //       r = reg.exec(str);
      //     }
      //     return rs;
      //   });
      //   console.table(arr.slice());
      //   // 通过递归计算相邻的矩阵
      //   let maxRect = (arr, result, n = 1) => {
      //     // 弹出第一行
      //     let top = arr.pop();
      //     // 弹出第二行
      //     let next = arr.pop();
      //     // 记录第一行的每一个起始点和截止点
      //     let tt;
      //     // 记录第二行的每一个起始点和截止点
      //     let nn;
      //     // 记录交叉的起始索引
      //     let start;
      //     // 记录交叉的截止索引
      //     let end;
      //     let width = 1;
      //     let maxWidth = 1;
      //     n++;
      //     for (let i = 0, il = top.length; i < il; i++) {
      //       tt = top[i];
      //       for (let j = 0, jl = next.length; j < jl; j++) {
      //         nn = next[j];
      //         width = Math.min(tt[1], nn[1]) - Math.max(tt[0], nn[0]);
      //         if (width > maxWidth) {
      //           maxWidth = width;
      //           start = Math.max(tt[0], nn[0]);
      //           end = Math.min(tt[1], nn[1]);
      //         }
      //       }
      //     }
      //     // 如果没有找到交叉点
      //     if (!start || !end) {
      //       if (n < 3) {
      //         return false;
      //       } else {
      //         width = top[0][1] - top[0][0] + 1;
      //         if (width > 1) {
      //           result.push((n - 1) * width);
      //         }
      //       }
      //     } else {
      //       if (arr.length > 0) {
      //         arr.push([[start, end]]);
      //         result.push(n * (end - start + 1));
      //         maxRect(arr, result, n++);
      //       } else {
      //         result.push(n * (end - start + 1));
      //       }
      //     }
      //   };
      //   while (arr.length > 1) {
      //     maxRect([].concat(arr), result);
      //     arr.pop();
      //   }

      //   let max = Math.max.apply(null, result);
      //   return max > 0 ? max : -1;
      // };

      // console.log(fn(arr));
    </script>
    <script>
      // 快排高级算法
      // let quickSort = arr => {
      //   let swap = (arr, i, j) => {
      //     let tmp = arr[i];
      //     arr[i] = arr[j];
      //     arr[j] = tmp;
      //   };
      //   // 完成一次划分交换
      //   let findCenter = (arr, left, right) => {
      //     let flag = arr[left];
      //     let idx = left + 1;
      //     for (let i = idx; i <= right; i++) {
      //       if (arr[i] < flag) {
      //         swap(arr, idx, i);
      //         idx++;
      //       }
      //     }
      //     swap(arr, left, idx - 1);
      //     return idx;
      //   };
      //   let sort = (arr, left, right) => {
      //     if (left < right) {
      //       let center = findCenter(arr, left, right);
      //       sort(arr, left, center - 1);
      //       sort(arr, center, right);
      //     }
      //   };
      //   sort(arr, 0, arr.length - 1);
      //   return arr;
      // };
      // let arr = [4, 1, 5, 2, 3];
      // console.log(quickSort(arr));
    </script>
    <script>
      // async function foo() {
      //   console.log("foo");
      // }
      // async function bar() {
      //   console.log("bar start");
      //   await foo();
      //   console.log("bar end");
      // }
      // console.log("script start");
      // setTimeout(function() {
      //   console.log("setTimeout");
      // }, 0);
      // bar();
      // new Promise(function(resolve) {
      //   console.log("promise executor");
      //   resolve();
      // }).then(function() {
      //   console.log("promise then");
      // });
      // console.log("script end");
      // script start
      // bar start
      // foo
      // promise executor
      // script end
      // bar end
      // promise then
      // setTimeout
    </script>
    <script>
      // BigInt
      // console.log("Number.MAX_SAFE_INTEGER: ", Number.MAX_SAFE_INTEGER);
      // console.log("Number.MIN_SAFE_INTEGER: ", Number.MIN_SAFE_INTEGER);
      // console.log(Number.MIN_SAFE_INTEGER - 5);
      // console.log(Number.MIN_SAFE_INTEGER - 4);
      // console.log(Number.MIN_SAFE_INTEGER - 3);
      // console.log(Math.pow(2, 53) - 1);
      // console.log("9999999999999999".length);
      // console.log("10000000000000000".length);
      // console.log(9999999999999999n);
      // console.log(9999999999999999);
      // console.log(BigInt("9007199254740995"));
      // console.log(10n + 10n);
      // console.log(Number(10n));
      // console.log(10n > 5);
      // console.log(10n > 5n);
      // console.log(BigInt(true) === 1n);
      // console.log(9007199254740992 === 9007199254740993);
    </script>
    <script>
      // 莫雷编码
      // let make = n => {
      //   if (n === 1) {
      //     return ["0", "1"];
      //   } else {
      //     let prev = make(n - 1);
      //     let result = [];
      //     let max = Math.pow(2, n) - 1;
      //     for (let i = 0, len = prev.length; i < len; i++) {
      //       result[i] = `0${prev[i]}`;
      //       result[max - i] = `1${prev[i]}`;
      //     }
      //     return result;
      //   }
      // };

      // function decimal(str) {
      //   let res = 0;
      //   for (let i = 0, l = str.length; i < l; i++) {
      //     res += str[i] * Math.pow(2, l - i - 1);
      //   }
      //   return res;
      // }
      // console.log(make(2).map(num => decimal(num)));
      // console.log(make(3).map(num => decimal(num)));
      // console.log(make(4).map(num => decimal(num)));

      // const f = (flowerbed, n) => {
      //   let result = 0;
      //   if (flowerbed[0] === 0 && flowerbed[1] === 0) {
      //     flowerbed[0] = 1;
      //     result++;
      //   } else if (
      //     flowerbed[flowerbed.length - 1] === 0 &&
      //     flowerbed[flowerbed.length - 2] === 0
      //   ) {
      //     flowerbed[flowerbed.length - 1] = 1;
      //     result++;
      //   }
      //   for (let i = 1, l = flowerbed.length; i < l; i++) {
      //     if (
      //       flowerbed[i] === 0 &&
      //       flowerbed[i - 1] === 0 &&
      //       flowerbed[i + 1] === 0
      //     ) {
      //       result++;
      //       flowerbed[i] = 1;
      //       i += 1;
      //       if (result >= n) {
      //         return true;
      //       }
      //     }
      //   }
      //   return result >= n;
      // };
      // console.log(f([1, 0, 0, 0, 1], 1));
      // console.log(f([1, 0, 0, 0, 1], 2));
      // console.log(f([1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], 3));
    </script>
    <script>
      // const name = "zhangqi";
      // "use strict";

      // function runStack(n) {
      //   if (n === 0) return 100;
      //   return setTimeout(function() {
      //     runStack(n - 2);
      //   }, 0);
      // }

      // let ha = arr => {
      //   // 卡牌排序
      //   let str = arr.sort().join("");
      //   // 分组
      //   let group = str.match(/(\d)\1+|\d/g);
      //   // 求最大公约数
      //   let gcd = (a, b) => {
      //     if (b === 0) {
      //       return a;
      //     } else {
      //       return gcd(b, a % b);
      //     }
      //   };

      //   while (group.length > 1) {
      //     let a = group.shift().length;
      //     let b = group.shift().length;
      //     let v = gcd(a, b);
      //     if (v === 1) {
      //       return false;
      //     } else {
      //       group.unshift("0".repeat(v));
      //     }
      //   }

      //   return group.length ? group[0].length > 1 : false;
      // };
      // console.log(ha([1, 1]));
      // console.log(ha([1, 1, 1, 2, 2, 2, 3, 3]));
    </script>
    <script>
      // let arr = [1, 2, 3, 4, 5];
      // let obj = {
      //   name: "zhangqi",
      //   age: 30
      // };
      // let container = document.querySelector("#container");
      // console.table(arr);
      // console.table(obj);
      // console.log(container);
      // console.dir(container);
      // console.log(
      //   "%c 请不要这样 %s",
      //   "background: #222;color:#bada55;font-size:30px;",
      //   ">>"
      // );
    </script>
    <script>
      // function mix(...mixins) {
      //   class Mix {
      //     constructor() {
      //       for (let mixin of mixins) {
      //         copyProperties(this, new mixin()); // 拷贝实例属性
      //       }
      //     }
      //   }

      //   for (let mixin of mixins) {
      //     copyProperties(Mix, mixin);
      //     copyProperties(Mix.prototype, mixin.prototype);
      //   }

      //   return Mix;
      // }

      // function copyProperties(target, source) {
      //   for (let key of Reflect.ownKeys(source)) {
      //     if (!["constructor", "prototype", "name"].includes(key)) {
      //       let desc = Object.getOwnPropertyDescriptor(source, key);
      //       Object.defineProperty(target, key, desc);
      //     }
      //   }
      // }

      // class A {
      //   constructor() {
      //     this.name = "a";
      //   }
      //   methodA() {
      //     console.log("methodA");
      //   }
      // }
      // class B {
      //   constructor() {
      //     this.name = "b";
      //   }
      //   methodB() {
      //     console.log("methodB");
      //   }
      // }
      // class C extends mix(A, B) {
      //   constructor() {
      //     super(...arguments);
      //   }
      // }
      // let c = new C();
      // console.log(c);
      // c.methodA();
    </script>
    <script>
      // class newObj extends Object {
      //   constructor() {
      //     super(...arguments);
      //   }
      // }
      // let o = new newObj({ attr: true });
      // console.log(o);
      // class ExtendableError extends Error {
      //   constructor(message) {
      //     super();
      //     this.message = message;
      //     this.stack = new Error().stack;
      //     this.name = this.constructor.name;
      //   }
      // }
      // class MyError extends ExtendableError {
      //   constructor(m) {
      //     super(m);
      //   }
      // }
      // let myerror = new MyError("ll");
      // console.log(myerror.message);
      // console.log(myerror instanceof Error);
      // console.log(myerror.name);
      // console.log(myerror.stack);
    </script>
    <script>
      // function MyArray() {
      //   Array.apply(this, arguments);
      // }
      // MyArray.prototype = Object.create(Array.prototype, {
      //   constructor: {
      //     value: MyArray,
      //     writable: true,
      //     configurable: true,
      //     enumerable: true
      //   }
      // });
      // class MyArray extends Array {
      //   constructor(...args) {
      //     super(...args);
      //     this.history = [[]];
      //   }
      //   commit() {
      //     this.history.push(this.slice());
      //   }
      //   revert() {
      //     this.splice(0, this.length, ...this.history[this.history.length - 1]);
      //   }
      // }
      // let x = new MyArray();
      // x.push(1);
      // x.push(2);
      // console.log(x);
      // console.log(x.history);

      // x.commit();
      // console.log(x.history);

      // x.push(3);
      // console.log(x);
      // console.log(x.history);

      // x.revert();
      // console.log(x);

      // let colors = new MyArray();
      // colors[0] = "red";
      // console.log(colors.length);

      // colors.length = 0;
      // console.log(colors[0]);

      // let e = {};
      // console.log(Object.getOwnPropertyNames(Error));
      // console.log(Object.getOwnPropertyNames(Error.prototype));
      // console.log(Object.getOwnPropertyNames(Error.call(e)));
      // console.log(Object.getOwnPropertyNames(e));
    </script>
    <script>
      // class Point {
      //   constructor() {
      //     this.x = 1;
      //   }
      //   init() {}
      //   get y() {
      //     return 2;
      //   }
      // }
      // class ColorPoint extends Point {
      //   constructor() {
      //     super();
      //     this.x = 2;
      //   }
      // }
      // let p1 = new Point();
      // let p2 = new ColorPoint();
      // console.log(p2.__proto__.__proto__.y);
      // console.log(p1.__proto__);
      // class A {}
      // console.log(A.__proto__ === Function.prototype);
      // console.log(A.prototype.__proto__ === Object.prototype);

      // class o extends Object {}
      // let obj = new o();
      // console.log(obj);
      // class A {}
      // // class B extends A {}
      // class B {}
      // Object.setPrototypeOf(B, A);
      // Object.setPrototypeOf(B.prototype, A.prototype);
      // console.log(B.__proto__ === A);
      // console.log(B.prototype.__proto__ === A.prototype);
    </script>
    <script>
      // let obj = {
      //   toString() {
      //     return "myObject: " + super.toString();
      //   }
      // };
      // console.log(obj.toString());
      // class Point {
      //   constructor() {
      //     this.x = 1;
      //   }
      //   init() {
      //     // console.log(this.x);
      //   }
      //   static myMethod(msg) {
      //     // console.log("instance", msg);
      //   }
      // }
      // class ColorPoint extends Point {
      //   constructor() {
      //     super();
      //     console.log(super.valueOf());
      //     this.x = 2;
      //     this.init();
      //   }

      //   init() {
      //     console.log(super.valueOf());
      //     super.init();
      //     super.y = 3;
      //     // console.log(super.y);
      //     // console.log(this.y);
      //     // console.log(super);
      //   }

      //   static myMethod(msg) {
      //     // console.log(this);
      //     super.myMethod(msg);
      //   }
      // }
      // Point.myMethod(1);
      // new Point();
      // let cp = new ColorPoint();
      // ColorPoint.myMethod(2);
    </script>
    <script>
      // class Shape {
      //   constructor() {
      //     if (new.target === Shape) {
      //       throw new Error("本类不能实例化");
      //     }
      //   }
      // }
      // let bar = Symbol("bar");
      // class Foo {
      //   _counter = 0;
      //   foo = "bar";
      //   static name = "zhangqi";

      //   constructor() {
      //     console.log(new.target === Foo);
      //   }

      //   foo(baz) {
      //     this[bar](baz);
      //   }
      //   [bar](baz) {
      //     return (this.snaf = baz);
      //   }
      // }
      // let foo = new Foo();
      // class Child extends Foo {
      //   constructor() {
      //     super();
      //     console.log(new.target);
      //   }
      // }
      // new Child();
      // console.log(Object.keys(Foo.prototype));
      // console.log(Reflect.ownKeys(Foo.prototype));
      // class Foo {
      //   static classMethod() {
      //     return "hello";
      //   }
      //   classMethod() {
      //     console.log("shili");
      //   }
      // }
      // Foo.classMethod();
      // let foo = new Foo();
      // foo.classMethod();

      // class Bar extends Foo {
      //   static classMethod() {
      //     return super.classMethod() + ", bar";
      //   }
      // }
      // console.log(Bar.classMethod());
    </script>
    <script>
      // function selfish(target) {
      //   const cache = new WeakMap();
      //   const handler = {
      //     get(target, key) {
      //       const value = Reflect.get(target, key);
      //       if (typeof value !== "function") {
      //         return value;
      //       }
      //       if (!cache.has(value)) {
      //         cache.set(value, value.bind(target));
      //       }
      //       return cache.get(value);
      //     }
      //   };
      //   const proxy = new Proxy(target, handler);
      //   return proxy;
      // }

      // class Logger {
      //   constructor() {}
      //   printName(name = "there") {
      //     this.print(`Hello ${name}`);
      //   }
      //   print(text) {
      //     console.log(text);
      //   }
      // }
      // let logger = selfish(new Logger());
      // const { printName } = logger;
      // printName();

      // const init = new (class Me {
      //   constructor(...args) {
      //     this.args = args;
      //   }
      //   *[Symbol.iterator]() {
      //     for (let arg of this.args) {
      //       yield arg;
      //     }
      //   }
      // })("hello", "world");
      // for (let x of init) {
      //   console.log(x);
      // }
      // let methodName = "getArea";
      // class Parent {
      //   constructor(x, y) {
      //     this.x = x;
      //     this.y = y;
      //   }

      //   say() {
      //     console.log(this.x, this.y);
      //   }

      //   get prop() {
      //     return "prop getter";
      //   }

      //   set prop(value) {
      //     console.log("prop setter: " + value);
      //   }

      //   [methodName]() {
      //     console.log("methodname getArea");
      //   }
      // }

      // let p = new Parent(1, 2);
      // console.log(p);

      // class Child extends Parent {
      //   constructor(x, y, z) {
      //     super(x, y);
      //     this.z = z;
      //   }
      // }

      // let c = new Child(1, 2, 3);
      // console.log(c);
    </script>
    <script>
      // let Chinese = { nation: "中国" };
      // // let Doctor = { career: "医生" };

      // function object(o) {
      //   function F() {}
      //   F.prototype = o;
      //   return new F();
      // }
      // // let Doctor = object(Chinese);
      // let Doctor = Object.create(Chinese, {
      //   color: {
      //     writable: true,
      //     configurable: true,
      //     value: "yellow"
      //   },
      //   type: {
      //     get() {
      //       return "convertibal";
      //     },
      //     set(value) {
      //       console.log("changed: " + "value");
      //     }
      //   }
      // });
      // Doctor.career = "医生";

      // console.log(Doctor);
      // console.log(Doctor.nation);
      // Doctor.type = "zhangqi";

      // function Animal() {}
      // Animal.prototype.species = "动物";

      // function Cat(name, color) {
      //   Animal.apply(this, arguments);
      //   this.name = name;
      //   this.color = color;
      // }

      // function extend(child, parent) {
      //   let F = function() {};
      //   F.prototype = parent.prototype;
      //   child.prototype = new F();
      //   child.prototype.constructor = child;
      // }

      // function extend2(child, parent) {
      //   let p = parent.prototype;
      //   let c = child.prototype;

      //   for (let i in p) {
      //     c[i] = p[i];
      //   }
      // }

      // extend2(Cat, Animal);

      // let animail = new Animal();
      // let cat = new Cat("huniu", "heibai");

      // console.log(animail);
      // console.log(cat);
    </script>
  </body>
</html>
