<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <style>
    html, body { width: 100%; height: 100%; }
    body { background-color: #000; }
  </style>
  <title>kira</title>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
let canvas = document.getElementById('canvas')
let context = canvas.getContext('2d')
let cw = canvas.width = window.innerWidth
let ch = canvas.height = window.innerHeight

function randomColor () {
  let num = 3
  let color = []
  while (num--) {
    color.push(Math.floor(Math.random() * 254 + 1))
  }
  return color.join(', ')
}

// 创建一个闪烁圆的类
class Kirakira {
  constructor (targetX, targetY) {
    this.targetLocation = { x: targetX, y: targetY }
    this.radius = 1
  }

  draw () {
    let { x, y } = this.targetLocation
    context.beginPath()
    context.arc(this.targetLocation.x, this.targetLocation.y, this.radius, 0, Math.PI * 2)
    context.lineWidth = 2
    context.strokeStyle = `rgba(${ randomColor() }, 1)`
    context.stroke()
  }

  update () {
    if (this.radius < 5) {
      this.radius += 0.3
    } else {
      this.radius = 1
    }
  }

  init () {
    this.draw()
    this.update()
  }
}

class Biubiubiu {
  constructor (startX, startY, targetX, targetY) {
    this.startLocation = { x: startX, y: startY }
    this.nowLocation = { x: startX, y: startY }
    this.targetLocation = { x: targetX, y: targetY }
    this.targetDistance = this.getDistance(this.startLocation.x, this.startLocation.y, this.targetLocation.x, this.targetLocation.y)
    // 速度
    this.speed = 2
    // 加速度
    this.acceleration = 1.02
    // 角度
    this.angle = Math.atan2(this.targetLocation.y - this.startLocation.y, this.targetLocation.x - this.startLocation.x)
    this.arrived = false
    // 线段集合，每次存10个，取10个帧的距离
    this.collection = new Array(10)
  }

  draw () {
    context.beginPath()
    try {
      context.moveTo(this.collection[0][0], this.collection[0][1])
    } catch (e) {
      context.moveTo(this.nowLocation.x, this.nowLocation.y)
    }
    context.lineWidth = 3
    context.lineCap = 'round'
    context.lineTo(this.nowLocation.x, this.nowLocation.y)
    context.strokeStyle = `rgba(${ randomColor() }, 1)`
    context.stroke()
  }

  update () {
    this.collection.shift()
    this.collection.push([this.nowLocation.x, this.nowLocation.y])

    this.speed *= this.acceleration
    // 计算当前帧的路程
    let vx = Math.cos(this.angle) * this.speed
    let vy = Math.sin(this.angle) * this.speed
    // 计算当前运动距离
    let nowDistance = this.getDistance(this.startLocation.x, this.startLocation.y, this.nowLocation.x + vx, this.nowLocation.y + vy)
    // 如果当前运动的距离产出目标点距离，则不需要继续运动
    if (nowDistance >= this.targetDistance) {
      this.arrived = true
    } else {
      this.nowLocation.x += vx
      this.nowLocation.y += vy
      this.arrived = false
    }
  }

  getDistance (x0, y0, x1, y1) {
    let locX = x1 - x0
    let locY = y1 - y0
    return Math.sqrt(Math.pow(locX, 2) + Math.pow(locY, 2))
  }

  init () {
    this.draw()
    this.update()
  }
}

class Boom {
  // 爆炸物是没有确定的结束点坐标， 这个可以通过设定一定的阀值来限定
  constructor (startX, startY) {
    this.startLocation = { x: startX, y: startY }
    this.nowLocation = { x: startX, y: startY }
    this.speed = Math.random() * 10 + 2
    this.acceleration = 0.95
    this.angle = Math.random() * Math.PI * 2
    this.targetCount = 100 // 阙值
    this.nowNum = 1 // 当前为1，用于判断是否会产出阙值
    this.alpha = 1 // 透明度
    this.grads = 0.015 // 透明度减少梯度
    this.gravity = 0.98 // 重力系数
    this.collection = new Array(10) // 线段集合
    this.arrived = false
  }

  draw () {
    context.beginPath()
    try {
      context.moveTo(this.collection[0][0], this.collection[0][1])
    } catch (e) {
      context.moveTo(this.nowLocation.x, this.nowLocation.y)
    }
    context.lineWidth = 3
    context.lineCap = 'round'
    context.lineTo(this.nowLocation.x, this.nowLocation.y)
    context.strokeStyle = `rgba(${ randomColor() }, ${ this.alpha })`
    context.stroke()
  }

  update () {
    this.collection.shift()
    this.collection.push([this.nowLocation.x, this.nowLocation.y])
    this.speed *= this.acceleration

    let vx = Math.cos(this.angle) * this.speed
    let vy = Math.sin(this.angle) * this.speed + this.gravity

    if (this.nowNum >= this.targetCount) {
      this.alpha -= this.grads
    } else {
      this.nowLocation.x += vx
      this.nowLocation.y += vy
      this.nowNum++
    }

    if (this.alpha <= 0) {
      this.arrived = true
    }
  }

  init () {
    this.draw()
    this.update()
  }
}

class Animate {
  constructor () {
    // 用于记录当前实例化的坐标点
    this.startX = null
    this.startY = null
    this.targetX = null
    this.targetY = null
    // 定义一个数组作为闪烁球的集合
    this.kiras = []
    // 定义一个数组作为射线类的集合
    this.bius = []
    // 定义一个数组作为爆炸类的集合
    this.booms = []
    // 避免每帧都进行绘制导致的过量绘制，设置阙值，到达阙值的时候在进行绘制
    this.timerTarget = 80
    this.timerNum = 0
  }

  pushBoom (x, y) {
    // 实例化爆炸效果，随机条数的射线扩散
    for (let bi = Math.random() * 10 + 20; bi > 0; bi--) {
      this.booms.push(new Boom(x, y))
    }
  }

  run () {
    window.requestAnimationFrame(this.run.bind(this))
    context.clearRect(0, 0, cw, ch)

    let biuNum = this.bius.length
    while (biuNum--) {
      this.bius[biuNum].init()
      this.kiras[biuNum].init()
      if (this.bius[biuNum].arrived) {
        this.pushBoom(this.bius[biuNum].nowLocation.x, this.bius[biuNum].nowLocation.y)

        this.bius.splice(biuNum, 1)
        this.kiras.splice(biuNum, 1)
      }
    }

    let bnum = this.booms.length
    while (bnum--) {
      this.booms[bnum].init()
      if (this.booms[bnum].arrived) {
        this.booms.splice(bnum, 1)
      }
    }

    if (this.timerNum >= this.timerTarget) {
      // 到达阀值后开始绘制实例化射线
      this.startX = Math.random() * (cw / 2)
      this.startY = ch
      this.targetX = Math.random() * cw
      this.targetY = Math.random() * (ch / 2)
      let exBiu = new Biubiubiu(this.startX, this.startY, this.targetX, this.targetY)
      let exKira = new Kirakira(this.targetX, this.targetY)
      this.bius.push(exBiu)
      this.kiras.push(exKira)
      // 到达阀值后把当前计数重置一下
      this.timerNum = 0
    } else {
      this.timerNum++
    }
  }
}

let a = new Animate()
a.run()








</script>
</body>
</html>