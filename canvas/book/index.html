<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../reset.css" />
  <script src="../public/utils.js"></script>
  <script src="../public/public.js"></script>
  <script src="../public/sprite.js"></script>
  <script src="../public/shape.js"></script>
  <style>
    #canvas {
      position: relative;
      /* margin: 100px; */
      /* border: 1px solid #ddd; */
    }

    #video {
      display: none;
    }

    #message {
      position: absolute;
      top: 25px;
      left: 25px;
      font-size: 30px;
    }
  </style>
  <title>book-study</title>
</head>

<body>
  <canvas id="canvas"></canvas>
  <div id="message"></div>
  <!-- <video id="video" src="../images/bg.mp4"></video> -->

  <script>
    //
    const canvasWidth = document.body.clientWidth;
    const canvasHeight = document.body.clientHeight;
    const middleX = canvasWidth / 2;
    const middleY = canvasHeight / 2;
    const canvas = document.getElementById("canvas");
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    const context = canvas.getContext("2d");

      // 画圆动画 start
      // const cx = 400;
      // const cy = 400;
      // const radius = 200;
      // let startAngle = 0;
      // let endAngle = Math.PI * 2;
      // const duration = 500;
      // let prevAngle = startAngle,
      //   nextAngle;
      // let startTime;

      // function drawCircle(currentTime) {
      //   if (!startTime) startTime = currentTime;
      //   const timeElapsed = currentTime - startTime;
      //   const progress = Math.min(timeElapsed / duration, 1);

      //   context.beginPath();
      //   nextAngle = startAngle + (endAngle - startAngle) * progress;
      //   context.arc(cx, cy, radius, prevAngle, nextAngle);
      //   prevAngle = nextAngle;
      //   context.stroke();

      //   requestAnimationFrame(drawCircle);
      // }

      // context.lineWidth = 7;
      // context.strokeStyle = "OrangeRed";
      // requestAnimationFrame(drawCircle);
      // 画圆动画 end

      // 折线动画 start
      // function handleExecute() {
      //   context.strokeStyle = "rgba(81, 160, 255, 1)";
      //   context.lineWidth = 7;
      //   context.lineJoin = "round";
      //   context.lineCap = "round";

      //   // 转折点坐标
      //   const keyPoints = [
      //     { x: 250, y: 200 },
      //     { x: 550, y: 200 },
      //     { x: 250, y: 500 },
      //     { x: 550, y: 500 },
      //     { x: 250, y: 200 },
      //   ];

      //   const duration = 1000;
      //   let prevX = keyPoints[0].x,
      //     prevY = keyPoints[0].y,
      //     nextX,
      //     nextY,
      //     startTime;

      //   const partProportion = 1 / (keyPoints.length - 1); // 每一段的时间
      //   let lineIndexCache = 1;

      //   const step = (currentTime) => {
      //     !startTime && (startTime = currentTime);
      //     const timeElapsed = currentTime - startTime;
      //     const progress = Math.min(timeElapsed / duration, 1);

      //     const lineIndex = Math.min(
      //       Math.floor(progress / partProportion) + 1,
      //       keyPoints.length - 1
      //     );
      //     const partProgress =
      //       (progress - (lineIndex - 1) * partProportion) / partProportion;

      //     const draw = () => {
      //       context.beginPath();
      //       context.moveTo(prevX, prevY);

      //       if (lineIndex !== lineIndexCache) {
      //         context.lineTo(
      //           keyPoints[lineIndex - 1].x,
      //           keyPoints[lineIndex - 1].y
      //         );
      //         lineIndexCache = lineIndex;
      //       }

      //       prevX = nextX = ~~(
      //         keyPoints[lineIndex - 1].x +
      //         (keyPoints[lineIndex].x - keyPoints[lineIndex - 1].x) *
      //           partProgress
      //       );
      //       prevY = nextY = ~~(
      //         keyPoints[lineIndex - 1].y +
      //         (keyPoints[lineIndex].y - keyPoints[lineIndex - 1].y) *
      //           partProgress
      //       );

      //       context.lineTo(nextX, nextY);
      //       context.stroke();
      //     };
      //     draw();

      //     if (progress < 1) {
      //       requestAnimationFrame(step);
      //     } else {
      //       console.log("done");
      //     }
      //   };
      //   requestAnimationFrame(step);
      // }
      // handleExecute();
      // 折线动画 end

      // 使用多条路径绘制直线动画 start
      // let count = 0;
      // function handleExecute() {
      //   context.strokeStyle = "rgba(81, 160, 255, 1)";
      //   context.lineWidth = 4;
      //   context.lineJoin = "round";

      //   const startX = 100;
      //   const startY = 100;
      //   const endX = canvasWidth - 100;
      //   const endY = canvasHeight - 100;
      //   const duration = 1000;
      //   let prevX = startX,
      //     prevY = startY,
      //     nextX,
      //     nextY,
      //     startTime;

      //   const step = (currentTime) => {
      //     !startTime && (startTime = currentTime);
      //     const timeElapsed = currentTime - startTime;
      //     const progress = Math.min(timeElapsed / duration, 1);

      //     const draw = () => {
      //       context.beginPath();
      //       context.moveTo(prevX, prevY);
      //       prevX = nextX = startX + (endX - startX) * progress;
      //       prevY = nextY = startY + (endY - startY) * progress;

      //       if (count % 2 === 0) {
      //         context.lineWidth = progress * 20;
      //         context.lineTo(nextX, nextY);
      //         context.stroke();
      //       }
      //     };
      //     draw();

      //     if (progress < 1) {
      //       count++;
      //       requestAnimationFrame(step);
      //     } else {
      //       console.log(count);
      //     }
      //   };
      //   requestAnimationFrame(step);
      // }
      // handleExecute();
      // 使用多条路径绘制直线动画 end

      //红色蒙版 start
      // const image = new Image();
      // image.src = "../images/1.jpg";
      // image.onload = function () {
      //   const imageWidth = image.width;
      //   const imageHeight = image.height;

      //   context.drawImage(image, 0, 0);

      //   const imageData = context.getImageData(0, 0, imageWidth, imageHeight);
      //   const data = imageData.data;
      //   for (let i = 0; i < data.length - 4; i += 4) {
      //     const average = (data[i] + data[i + 1] + data[i + 2]) / 3;
      //     data[i] = average;
      //     data[i + 1] = 0;
      //     data[i + 2] = 0;
      //   }
      //   context.putImageData(imageData, 600, 0);

      //   const imageData2 = context.getImageData(0, 0, imageWidth, imageHeight);
      //   const data2 = imageData2.data;
      //   for (let i = 0; i < data2.length - 4; i += 4) {
      //     const average =
      //       data2[i] * 0.3 + data2[i + 1] * 0.6 + data2[i + 2] * 0.1;
      //     data2[i] = 0;
      //     data2[i + 1] = average;
      //     data2[i + 2] = 0;
      //   }
      //   context.putImageData(imageData2, 0, 450);

      //   const imageData3 = context.getImageData(0, 0, imageWidth, imageHeight);
      //   const data3 = imageData3.data;
      //   for (let i = 0; i < data3.length - 4; i += 4) {
      //     const average =
      //       data3[i] * 0.3 + data3[i + 1] * 0.6 + data3[i + 2] * 0.1;
      //     data3[i] = 0;
      //     data3[i + 1] = 0;
      //     data3[i + 2] = average;
      //   }
      //   context.putImageData(imageData3, 600, 450);
      // };
      //红色蒙版 end

      // 加权平均值实现灰度图片 start
      // const image = new Image();
      // image.src = "../images/1.jpg";
      // image.onload = function () {
      //   const imageWidth = image.width;
      //   const imageHeight = image.height;

      //   context.drawImage(image, 0, 0);

      //   const imageData = context.getImageData(0, 0, imageWidth, imageHeight);
      //   const data = imageData.data;
      //   for (let i = 0; i < data.length - 4; i += 4) {
      //     const average = (data[i] + data[i + 1] + data[i + 2]) / 3;
      //     data[i] = average;
      //     data[i + 1] = average;
      //     data[i + 2] = average;
      //   }
      //   context.putImageData(imageData, 600, 0);

      //   const imageData2 = context.getImageData(0, 0, imageWidth, imageHeight);
      //   const data2 = imageData2.data;
      //   for (let i = 0; i < data2.length - 4; i += 4) {
      //     const average =
      //       data2[i] * 0.3 + data2[i + 1] * 0.6 + data2[i + 2] * 0.1;
      //     data2[i] = average;
      //     data2[i + 1] = average;
      //     data2[i + 2] = average;
      //   }
      //   context.putImageData(imageData2, 600, 450);
      // };
      // 加权平均值实现灰度图片 end

      // 绳球运动 start
      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2);
      // const mouse = tools.getMouse(canvas);
      // const targetX = canvasWidth / 2;
      // const spring = 0.02; // 弹性系数
      // const friction = 0.95; // 摩擦系数
      // const gravity = 1;
      // let vx = 0,
      //   vy = 0;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const ax = (mouse.x - ball.x) * spring;
      //   const ay = (mouse.y - ball.y) * spring;
      //   vx += ax;
      //   vy += ay;
      //   vy += gravity;
      //   vx *= friction;
      //   vy *= friction;
      //   ball.x += vx;
      //   ball.y += vy;
      //   ball.fill(context);

      //   context.beginPath();
      //   context.strokeStyle = "#69f";
      //   context.moveTo(ball.x, ball.y);
      //   context.lineTo(mouse.x, mouse.y);
      //   context.stroke();

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 绳球运动 end

      // 跟随鼠标的弹性动画 start
      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2);
      // const mouse = tools.getMouse(canvas);
      // const spring = 0.02; // 弹性系数
      // const friction = 0.95; // 摩擦系数
      // let vx = 0,
      //   vy = 0;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const ax = (mouse.x - ball.x) * spring;
      //   const ay = (mouse.y - ball.y) * spring;
      //   vx += ax;
      //   vy += ay;
      //   vx *= friction;
      //   vy *= friction;
      //   ball.x += vx;
      //   ball.y += vy;
      //   ball.fill(context);

      //   context.beginPath();
      //   context.strokeStyle = "#69f";
      //   context.moveTo(ball.x, ball.y);
      //   context.lineTo(mouse.x, mouse.y);
      //   context.stroke();

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 跟随鼠标的弹性动画 end

      // 弹性动画 start
      // const ball = new Ball(0, canvasHeight / 2);
      // const targetX = canvasWidth / 2;
      // const spring = 0.02; // 弹性系数
      // const friction = 0.95; // 摩擦系数
      // let vx = 0;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const ax = (targetX - ball.x) * spring;
      //   vx += ax;
      //   vx *= friction;
      //   ball.x += vx;
      //   ball.fill(context);
      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 弹性动画 end

      // 缓动动画作用于小球半径，透明度，颜色 start
      // const ball = new Ball(
      //   canvasWidth / 2,
      //   canvasHeight / 2,
      //   30,
      //   "rgba(255, 102, 153, 1)"
      // );
      // const easing = 0.02;
      // const targetRadius = 360;
      // let opacity = 1;
      // const targetOpacity = 0;
      // let red = 255;
      // let green = 0;
      // let blue = 0;
      // const targetRed = 10;
      // const targetGreen = 255;
      // const targetBlue = 55;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   // const vRadius = (targetRadius - ball.radius) * easing;
      //   // ball.radius += vRadius;
      //   // const vOpacity = (targetOpacity - opacity) * easing;
      //   // opacity += vOpacity;
      //   // ball.color = `rgba(255, 102, 153, ${opacity})`;
      //   const vRed = (targetRed - red) * easing;
      //   const vGreen = (targetGreen - green) * easing;
      //   const vBlue = (targetBlue - blue) * easing;
      //   red += vRed;
      //   green += vGreen;
      //   blue += vBlue;
      //   ball.color = `rgba(${red}, ${green}, ${blue}, 1)`;
      //   ball.fill(context);

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 缓动动画作用于小球半径，透明度，颜色 end

      // 小球追随鼠标的缓动动画，第二个小球跟随第一个小球动 start
      // const bigBall = new Ball(canvasWidth / 2, canvasHeight / 2, 15, "#f69");
      // const smallBall = new Ball(canvasWidth / 2, canvasHeight / 2, 12, "#6cf");
      // const mouse = tools.getMouse(canvas);
      // const easing = 0.05;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const vx1 = (mouse.x - bigBall.x) * easing;
      //   const vy1 = (mouse.y - bigBall.y) * easing;
      //   bigBall.x += vx1;
      //   bigBall.y += vy1;
      //   bigBall.fill(context);

      //   const vx2 = (bigBall.x - smallBall.x) * easing;
      //   const vy2 = (bigBall.y - smallBall.y) * easing;
      //   smallBall.x += vx2;
      //   smallBall.y += vy2;
      //   smallBall.fill(context);

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 小球追随鼠标的缓动动画，第二个小球跟随第一个小球动 end

      // 小球追随鼠标的缓动动画 start
      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2, 15, "#f69");
      // const easing = 0.05;
      // const loc = tools.getMouse(canvas);

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const vx = (loc.x - ball.x) * easing;
      //   const vy = (loc.y - ball.y) * easing;
      //   ball.x += vx;
      //   ball.y += vy;
      //   ball.fill(context);

      //   context.beginPath();
      //   context.strokeStyle = "OrangeRed";
      //   context.moveTo(ball.x, ball.y);
      //   context.lineTo(loc.x, loc.y);
      //   context.stroke();

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 小球追随鼠标的缓动动画 end

      // 任意方向缓动动画 start
      // const ball = new Ball(0, 0);
      // const targetX = (canvasWidth * 3) / 4;
      // const targetY = canvasHeight / 2;
      // const easing = 0.04;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const vx = (targetX - ball.x) * easing;
      //   const vy = (targetY - ball.y) * easing;
      //   ball.x += vx;
      //   ball.y += vy;

      //   if (targetX - ball.x >= 0.001 || targetY - ball.y >= 0.001) {
      //     requestAnimationFrame(drawFrame);
      //   } else {
      //     ball.x = targetX;
      //     ball.y = targetY;
      //   }

      //   ball.fill(context);
      // }
      // drawFrame();
      // 任意方向缓动动画 end

      // 单方向缓动动画 start
      // const ball = new Ball(0, canvasHeight / 2);
      // const targetX = (canvasWidth * 3) / 4;
      // const easing = 0.05;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const vx = (targetX - ball.x) * easing;
      //   ball.x += vx;

      //   console.log(targetX - ball.x, vx);

      //   if (targetX - ball.x > 0.01) {
      //     requestAnimationFrame(drawFrame);
      //   } else {
      //     ball.x = targetX;
      //   }

      //   ball.fill(context);
      // }
      // drawFrame();
      // 单方向缓动动画 end

      // 抛掷物体 start
      // let isMousedown = false;
      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2, 20);
      // ball.fill(context);
      // let dx = 0,
      //   dy = 0,
      //   oldX,
      //   oldY,
      //   vx = 0,
      //   vy = 0,
      //   gravity = 1.5,
      //   bounce = -0.8,
      //   friction = 0.985;

      // canvas.onmousedown = (e) => {
      //   e.preventDefault();
      //   const loc = windowToCanvas(canvas, e.clientX, e.clientY);
      //   if (ball.checkMouse(loc)) {
      //     oldX = ball.x;
      //     oldY = ball.y;
      //     dx = loc.x - ball.x;
      //     dy = loc.y - ball.y;

      //     isMousedown = true;

      //     canvas.onmousemove = (e) => {
      //       const loc = windowToCanvas(canvas, e.clientX, e.clientY);
      //       ball.x = loc.x - dx;
      //       ball.y = loc.y - dy;

      //       if (ball.x < ball.radius) {
      //         ball.x = ball.radius;
      //       } else if (ball.x > canvasWidth - ball.radius) {
      //         ball.x = canvasWidth - ball.radius;
      //       } else if (ball.y < ball.radius) {
      //         ball.y = ball.radius;
      //       } else if (ball.y > canvasHeight - ball.radius) {
      //         ball.y = canvasHeight - ball.radius;
      //       }
      //     };
      //     canvas.onmouseup = (_) => {
      //       canvas.onmousemove = null;
      //       canvas.onmouseup = null;
      //       isMousedown = false;
      //     };
      //   }
      // };
      // function checkBorder(ball) {
      //   if (ball.x < ball.radius) {
      //     ball.x = ball.radius;
      //     vx = bounce * vx;
      //   } else if (ball.x > canvasWidth - ball.radius) {
      //     ball.x = canvasWidth - ball.radius;
      //     vx = bounce * vx;
      //   } else if (ball.y < ball.radius) {
      //     ball.y = ball.radius;
      //     vy = bounce * vy;
      //   } else if (ball.y > canvasHeight - ball.radius) {
      //     ball.y = canvasHeight - ball.radius;
      //     vy = bounce * vy;
      //   }
      // }
      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   if (isMousedown) {
      //     vx = ball.x - oldX;
      //     vy = ball.y - oldY;
      //     oldX = ball.x;
      //     oldY = ball.y;
      //   } else {
      //     vy += gravity;
      //     vx *= friction;
      //     ball.x += vx;
      //     ball.y += vy;
      //     checkBorder(ball);
      //   }
      //   ball.fill(context);
      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 抛掷物体 end

      // 捕获动态小球 start
      // let frame = null;
      // const ball = new Ball(0, canvasHeight / 2, 30, "OrangeRed");
      // ball.fill(context);

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ball.x += 2;
      //   ball.fill(context);
      //   frame = requestAnimationFrame(drawFrame);
      // }
      // drawFrame();

      // document.addEventListener("click", (e) => {
      //   const loc = windowToCanvas(canvas, e.clientX, e.clientY);
      //   if (ball.checkMouse(loc)) {
      //     cancelAnimationFrame(frame);
      //   }
      // });
      // 捕获动态小球 end

      // 捕获静态小球 start
      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2, 30);
      // ball.fill(context);
      // canvas.addEventListener("mousemove", (e) => {
      //   const loc = windowToCanvas(canvas, e.clientX, e.clientY);
      //   if (ball.checkMouse(loc)) {
      //     console.log("被移入小球");
      //   } else {
      //     console.log("被移出小球");
      //   }
      //   // context.save();
      //   // context.beginPath();
      //   // context.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      //   // if (context.isPointInPath(loc.x, loc.y)) {
      //   //   console.log("被移入小球");
      //   // } else {
      //   //   console.log("被移出小球");
      //   // }
      //   // context.restore();
      // });
      // 捕获静态小球 end

      // 多物体碰撞检测 start
      // const balls = [];
      // const n = 50;
      // const radius = 10;
      // const deviation = radius / 5;

      // for (let i = 0; i < n; i++) {
      //   const ball = new Ball();
      //   ball.x = Math.random() * canvasWidth;
      //   ball.y = Math.random() * canvasHeight;
      //   ball.radius = radius;
      //   ball.color = randomColor();
      //   ball.vx = Math.random() * 2 - 1;
      //   ball.vy = Math.random() * 2 - 1;
      //   balls.push(ball);
      // }
      // function checkCollision(ballA, i) {
      //   for (let j = i + 1; j < balls.length; j++) {
      //     const ballB = balls[j];
      //     if (tools.checkCircle(ballB, ballA)) {
      //       ballA.vx = -ballA.vx;
      //       ballA.vy = -ballA.vy;
      //       ballB.vx = -ballB.vx;
      //       ballB.vy = -ballB.vy;
      //       // 每次碰撞，为小球的x,y加上偏移量，避免相互重叠
      //       if (ballA.vx > 0) {
      //         ballA.x += deviation;
      //       } else {
      //         ballA.x -= deviation;
      //       }
      //       if (ballA.vy > 0) {
      //         ballA.y += deviation;
      //       } else {
      //         ballA.y -= deviation;
      //       }
      //       if (ballB.vx > 0) {
      //         ballB.x += deviation;
      //       } else {
      //         ballB.x -= deviation;
      //       }
      //       if (ballB.vy > 0) {
      //         ballB.y += deviation;
      //       } else {
      //         ballB.y -= deviation;
      //       }
      //     }
      //   }
      // }
      // function checkBorder(ball) {
      //   if (ball.x < ball.radius) {
      //     ball.x = ball.radius;
      //     ball.vx = -ball.vx;
      //   } else if (ball.x > canvasWidth - ball.radius) {
      //     ball.x = canvasWidth - ball.radius;
      //     ball.vx = -ball.vx;
      //   } else if (ball.y < ball.radius) {
      //     ball.y = ball.radius;
      //     ball.vy = -ball.vy;
      //   } else if (ball.y > canvasHeight - ball.radius) {
      //     ball.y = canvasHeight - ball.radius;
      //     ball.vy = -ball.vy;
      //   }
      // }
      // function drawBall(ball) {
      //   ball.fill(context);
      //   ball.x += ball.vx;
      //   ball.y += ball.vy;
      // }
      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   balls.forEach(checkCollision);
      //   balls.forEach(checkBorder);
      //   balls.forEach(drawBall);
      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 多物体碰撞检测 end

      // 小球碰撞反弹 start
      // const ballA = new Ball(0, canvasHeight / 2, 12, "#6cf");
      // const ballB = new Ball(canvasWidth, canvasHeight / 2, 12, "#f69");

      // let vx = 2;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ballA.x += vx;
      //   ballB.x -= vx;
      //   if (tools.checkCircle(ballB, ballA)) {
      //     vx = -vx;
      //   }
      //   ballA.fill(context);
      //   ballB.fill(context);

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 小球碰撞反弹 end

      // 外接圆碰撞检测 start
      // const ballA = new Ball(canvasWidth / 2, canvasHeight / 2, 20, "#f69");
      // const ballB = new Ball(100, 100, 20, "#08c");

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ballA.fill(context);
      //   ballB.fill(context);
      //   if (tools.checkCircle(ballB, ballA)) {
      //     console.log("撞上了");
      //   } else {
      //     console.log("没撞上");
      //   }
      // }
      // window.addEventListener("mousemove", (e) => {
      //   const loc = windowToCanvas(canvas, e.clientX, e.clientY);
      //   ballB.x = loc.x;
      //   ballB.y = loc.y;
      //   drawFrame();
      // });
      // 外接圆碰撞检测 end

      // 俄罗斯方块 start
      // const boxes = [];
      // let activeBox = createBox();
      // let vy = 1.5;

      // function createBox() {
      //   let x = Math.random() * canvasWidth;
      //   let y = 0;
      //   let width = Math.random() * 40 + 10;
      //   let height = Math.random() * 40 + 10;
      //   let color = randomColor();
      //   let box = new Box(x, y, width, height, color);
      //   boxes.push(box);
      //   return box;
      // }
      // window.addEventListener("keydown", (e) => {
      //   switch (e.which) {
      //     case 40:
      //       activeBox.y += 5;
      //       break;
      //     case 37:
      //       activeBox.x -= 5;
      //       break;
      //     case 39:
      //       activeBox.x += 5;
      //       break;
      //   }
      // });
      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   activeBox.y += vy;
      //   if (activeBox.y > canvasHeight - activeBox.height) {
      //     activeBox.y = canvasHeight - activeBox.height;
      //     activeBox = createBox();
      //   }
      //   boxes.forEach((box) => {
      //     if (activeBox !== box && tools.checkRect(activeBox, box)) {
      //       activeBox.y = box.y - activeBox.height;
      //       activeBox = createBox();
      //     }
      //     box.fill(context);
      //   });
      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 俄罗斯方块 end

      // 外接矩形碰撞检测 start
      // const ballA = new Ball(canvasWidth / 2, canvasHeight / 2, 30);
      // const rectA = ballA.getRect();
      // ballA.fill(context);

      // let ballB = new Ball(0, 0, 30);

      // function drawMoveRect(loc) {
      //   ballB.x = loc.x;
      //   ballB.y = loc.y;
      //   ballB.fill(context);
      //   const rectB = ballB.getRect();
      //   context.strokeRect(rectB.x, rectB.y, rectB.width, rectB.height);
      // }

      // canvas.onmousemove = function (e) {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   const loc = windowToCanvas(canvas, e.clientX, e.clientY);
      //   ballA.fill(context);
      //   context.strokeRect(rectA.x, rectA.y, rectA.width, rectA.height);
      //   drawMoveRect(loc);

      //   if (tools.checkRect(ballA.getRect(), ballB.getRect())) {
      //     document.getElementById("message").innerHTML = "撞上了";
      //   } else {
      //     document.getElementById("message").innerHTML = "没撞上";
      //   }
      // };
      // 外接矩形碰撞检测 end

      // 边界反弹 多球 start
      // const balls = [];
      // const len = 50;

      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2);
      // for (let i = 0; i < len; i++) {
      //   const ball = new Ball(
      //     canvasWidth / 2,
      //     canvasHeight / 2,
      //     10,
      //     randomColor()
      //   );
      //   ball.vx = (Math.random() * 2 - 1) * 10;
      //   ball.vy = (Math.random() * 2 - 1) * 10;

      //   balls.push(ball);
      // }
      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   balls.forEach((ball) => {
      //     ball.x += ball.vx;
      //     ball.y += ball.vy;
      //     if (ball.x < ball.radius) {
      //       ball.x = ball.radius;
      //       ball.vx = -ball.vx;
      //     } else if (ball.x > canvasWidth - ball.radius) {
      //       ball.x = canvasWidth - ball.radius;
      //       ball.vx = -ball.vx;
      //     } else if (ball.y < ball.radius) {
      //       ball.y = ball.radius;
      //       ball.vy = -ball.vy;
      //     } else if (ball.y > canvasHeight - ball.radius) {
      //       ball.y = canvasHeight - ball.radius;
      //       ball.vy = -ball.vy;
      //     }
      //     ball.fill(context);
      //   });

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 边界反弹 多球 end

      // 边界反弹 start
      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2);
      // let vx = (Math.random() * 2 - 1) * 30;
      // let vy = (Math.random() * 2 - 1) * 30;
      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ball.x += vx;
      //   ball.y += vy;
      //   if (ball.x < ball.radius) {
      //     ball.x = ball.radius;
      //     vx = -vx;
      //   } else if (ball.x > canvasWidth - ball.radius) {
      //     ball.x = canvasWidth - ball.radius;
      //     vx = -vx;
      //   } else if (ball.y < ball.radius) {
      //     ball.y = ball.radius;
      //     vy = -vy;
      //   } else if (ball.y > canvasHeight - ball.radius) {
      //     ball.y = canvasHeight - ball.radius;
      //     vy = -vy;
      //   }
      //   ball.fill(context);

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 边界反弹 end

      // 边界生成 start
      // const balls = [];
      // const len = 500;
      // for (let i = 0; i < len; i++) {
      //   const ball = new Ball(
      //     canvasWidth / 2,
      //     canvasHeight / 2,
      //     10,
      //     randomColor()
      //   );
      //   // ball.vx = (Math.random() * 2 - 1) * 3;
      //   ball.vx = Math.random() + 3;
      //   ball.vy = (Math.random() * 2 - 1) * 3;

      //   balls.push(ball);
      // }
      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   balls.forEach((ball) => {
      //     if (
      //       ball.x < -ball.radius ||
      //       ball.x > canvasWidth + ball.radius ||
      //       ball.y < -ball.radius ||
      //       ball.y > canvasHeight + ball.radius
      //     ) {
      //       ball.x = canvasWidth / 2;
      //       ball.y = canvasHeight / 2;
      //       // ball.vx = (Math.random() * 2 - 1) * 3;
      //       ball.vx = Math.random() + 3;
      //       ball.vy = (Math.random() * 2 - 1) * 3;
      //     }
      //     ball.fill(context);
      //     ball.x += ball.vx;
      //     ball.y += ball.vy;
      //   });

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 边界生成 end

      // 边界环绕 start
      // const ball = new Ball(canvasWidth / 2, canvasHeight / 2);
      // ball.fill(context);
      // window.addEventListener("keydown", (e) => {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);

      //   switch (e.which) {
      //     case 38:
      //       ball.y -= 5;
      //       if (ball.y < -ball.radius) {
      //         ball.y = canvasHeight + ball.radius;
      //       }
      //       break;
      //     case 40:
      //       ball.y += 5;
      //       if (ball.y > canvasHeight + ball.radius) {
      //         ball.y = -ball.radius;
      //       }
      //       break;
      //     case 37:
      //       ball.x -= 5;
      //       if (ball.x < -ball.radius) {
      //         ball.x = canvasWidth + ball.radius;
      //       }
      //       break;
      //     case 39:
      //       ball.x += 5;
      //       if (ball.x > canvasWidth + ball.radius) {
      //         ball.x = -ball.radius;
      //       }
      //       break;
      //   }
      //   ball.fill(context);
      // });
      // 边界环绕 end

      // 小球任意方向摩擦力 start
      // const ball = new Ball();
      // let speed = 8;
      // const angle = 45;
      // let vx = speed * Math.cos((angle * Math.PI) / 180);
      // let vy = speed * Math.sin((angle * Math.PI) / 180);
      // const friction = 0.97;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);

      //   ball.x += vx;
      //   ball.y += vy;
      //   ball.fill(context);

      //   vx *= friction;
      //   vy *= friction;

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 小球任意方向摩擦力 end

      // 小球水平摩擦力 start
      // const ball = new Ball(0, canvasHeight / 2);
      // let vx = 8;
      // const friction = 0.97;

      // function frame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ball.x += vx;
      //   ball.fill(context);
      //   vx *= friction;
      //   requestAnimationFrame(frame);
      // }
      // frame();
      // 小球水平摩擦力 end

      // 模拟小球水平抛出动画 start
      // const ball = new Ball(0, canvasHeight);
      // let vx = 3;
      // let vy = -6;
      // let gravity = 0.2;
      // let friction = 0.985; // 摩擦系数
      // let bounce = -0.75;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ball.x += vx;
      //   ball.y += vy;

      //   if (ball.y + ball.radius > canvasHeight) {
      //     ball.y = canvasHeight - ball.radius;
      //     vy *= bounce;
      //   }

      //   if (vy < 0.05) {
      //     vx *= friction;
      //   }

      //   ball.fill(context);

      //   vy += gravity;

      //   if (vx > 0) {
      //     requestAnimationFrame(drawFrame);
      //   }
      // }
      // drawFrame();
      // 模拟小球水平抛出动画 end

      // 小球垂直落地反弹 start
      // const ball = new Ball(canvasWidth / 2, 0);
      // const gravity = 0.5; // 重力加速度
      // const bounce = -0.5; // 反弹系数，绝对值越大，反弹越多
      // let vy = 0;

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ball.y += vy;
      //   if (ball.y > canvasHeight - ball.radius) {
      //     ball.y = canvasHeight - ball.radius;
      //     // 到达底部，速度反向，因为有速度损耗，要减小
      //     vy *= bounce;
      //   }
      //   ball.fill(context);
      //   vy += gravity;

      //   requestAnimationFrame(drawFrame);
      // }
      // drawFrame();
      // 小球落地反弹 end

      // 重力 start
      // const ball = new Ball(0, canvasHeight);
      // let vx = 8;
      // let vy = -9.81;
      // let gravity = 0.2;
      // const points = [[ball.x, ball.y]];

      // function drawFrame() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      //   ball.x += vx;
      //   ball.y += vy;
      //   ball.fill(context);

      //   points.push([ball.x, ball.y]);

      //   vy += gravity;

      //   context.beginPath();
      //   context.moveTo(points[0][0], points[0][1]);
      //   for (let i = 1; i < points.length; i++) {
      //     context.lineTo(points[i][0], points[i][1]);
      //   }
      //   context.stroke();

      //   if (ball.y <= canvasHeight + ball.radius) {
      //     requestAnimationFrame(drawFrame);
      //   }
      // }
      // drawFrame();
      // 重力 end

      // 椭圆 start
      // const radiusX = 200;
      // const radiusY = 100;
      // let angle = 0;

      // context.translate(300, 300);
      // context.lineWidth = 0.5;
      // context.strokeStyle = "OrangeRed";
      // context.fillStyle = "OrangeRed";
      // context.moveTo(radiusX, 0);
      // for (let i = 1; i <= 360; i++) {
      //   angle += Math.PI / 180;
      //   context.lineTo(Math.cos(angle) * radiusX, Math.sin(angle) * radiusY);
      //   context.stroke();
      //   context.fill();
      // }
      // 椭圆 end
      // 视差滚动 start
      // let beafWidth = 0,
      //   beafHeight = 0,
      //   lastTime = 0,
      //   fps,
      //   catOffset,
      //   beafOffset;
      // const CAT_VELOCITY = 20;
      // const BEAF_VELOCITY = 100;

      // const cat = new Image();
      // const beaf = new Image();
      // cat.src = "../images/5.jpg";
      // beaf.src = "../images/beaf.jpg";
      // beaf.onload = function () {
      //   beafWidth = beaf.width;
      //   beafHeight = beaf.height;
      //   context.drawImage(cat, 0, 0, canvasWidth, canvasHeight);
      //   context.drawImage(
      //     beaf,
      //     canvasWidth - beafWidth,
      //     0,
      //     beafWidth,
      //     beafHeight
      //   );
      // };

      // function calculateFps(now) {
      //   let fps = 1000 / (now - lastTime);
      //   lastTime = now;
      //   return fps;
      // }

      // function erase() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      // }

      // function draw() {
      //   catOffset =
      //     catOffset < canvasWidth ? catOffset + CAT_VELOCITY / fps : 0;
      //   beafOffset =
      //     beafOffset < canvasWidth ? beafOffset + BEAF_VELOCITY / fps : 0;

      //   context.save();
      //   context.translate(-catOffset, 0);
      //   context.drawImage(cat, 0, 0, canvasWidth, canvasHeight);
      //   context.drawImage(cat, canvasWidth, 0, canvasWidth, canvasHeight);
      //   context.restore();

      //   context.save();
      //   context.translate(-beafOffset, 0);
      //   context.drawImage(
      //     beaf,
      //     canvasWidth - beafWidth,
      //     0,
      //     beafWidth,
      //     beafHeight
      //   );
      //   context.drawImage(
      //     beaf,
      //     canvasWidth * 2 - beafWidth,
      //     0,
      //     beafWidth,
      //     beafHeight
      //   );
      //   context.restore();
      // }

      // function animate() {
      //   fps = calculateFps(Date.now());

      //   erase();
      //   draw();

      //   requestAnimationFrame(animate);
      // }

      // canvas.onclick = function () {
      //   animate();
      // };
      // 视差滚动 end

      // 背景滚动 start
      // const image = new Image();
      // let imageOffset = 0;
      // let fps = 0;
      // let lastTime = 0;
      // const SKY_VELOCITY = 30;

      // function erase() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight);
      // }
      // function draw() {
      //   imageOffset =
      //     imageOffset < canvasWidth ? imageOffset + SKY_VELOCITY / fps : 0;

      //   context.save();
      //   context.translate(-imageOffset, 0);
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight);
      //   context.drawImage(image, canvasWidth, 0, canvasWidth, canvasHeight);

      //   context.restore();
      // }
      // function calculateFps(now) {
      //   let fps = 1000 / (now - lastTime);
      //   lastTime = now;
      //   return fps;
      // }
      // function animate(now) {
      //   if (now == undefined) {
      //     now = Date.now();
      //   }
      //   fps = calculateFps(now);
      //   if (fps > 0) {
      //     erase();
      //     draw();
      //   }
      //   requestAnimationFrame(animate);
      // }

      // image.src = "../images/5.jpg";
      // image.onload = function () {
      //   draw();
      // };
      // canvas.onclick = function () {
      //   animate();
      // };
      // 背景滚动 end

      // 双缓冲技术检测 start
      // let sum = 0
      // function animate() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight)
      //   for (let i = 0;i<500000;i++) {
      //     sum+=i
      //   }
      //   context.fillStyle = 'OrangeRed'
      //   context.fillRect(0, 0, canvasWidth, canvasHeight)

      //   requestAnimationFrame(animate)
      // }
      // animate()
      // 双缓冲技术检测 end

      // 计算 fps start
      // let lastTime = 0
      // function calculateFps() {
      //   let now = Date.now()
      //   let fps = 1000 / (now - lastTime)

      //   lastTime = now

      //   return fps
      // }
      // function animate() {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight)
      //   context.fillStyle = 'cornflowerblue'
      //   context.font = 'bold 40px arial'
      //   context.fillText(calculateFps().toFixed() + ' fps', 20, 60)
      //   window.requestAnimationFrame(animate)
      // }
      // animate()
      // 计算 fps end
      // 播放视频 start
      // const video = document.getElementById('video')
      // function animate() {
      //   if (!video.ended) {
      //     context.drawImage(video, 0, 0)
      //     window.requestAnimationFrame(animate)
      //   }
      // }
      // canvas.onclick = function () {
      //   video.play()
      //   animate()
      // }
      // 播放视频 end

      // 滤镜实现淡出动画 start
      // let interval = null
      // let originalImageData = null
      // const image = new Image()
      // image.src = '../images/2.jpg'
      // image.onload = function () {
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      //   originalImageData = context.getImageData(0, 0, canvasWidth, canvasHeight)
      // }
      // function fadeOut(context, imageData, x, y, steps, millisecondsPerStep) {
      //   let frame = 0,
      //     length = imageData.data.length

      //   interval = setInterval(() => {
      //     frame++
      //     if (frame > steps) {
      //       clearInterval(interval)
      //       animationComplete()
      //     } else {
      //       increaseTransparency(imageData, steps)
      //       context.putImageData(imageData, x, y)
      //     }
      //   }, millisecondsPerStep)
      // }
      // function increaseTransparency(imageData, steps) {
      //   let alpha, currentAlpha, step, length = imageData.data.length

      //   for (let i = 3; i < length; i += 4) {
      //     alpha = originalImageData.data[i]
      //     if (alpha > 0 && imageData.data[i] > 0) {
      //       currentAlpha = imageData.data[i]
      //       step = Math.ceil(alpha / steps)

      //       if (currentAlpha - step > 0) {
      //         imageData.data[i] -= step
      //       } else {
      //         imageData.data[0] = 0
      //       }
      //     }
      //   }
      // }
      // function animationComplete() {
      //   setTimeout(() => {
      //     context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      //   }, 1000)
      // }
      // canvas.onclick = function () {
      //   fadeOut(context, context.getImageData(0, 0, canvasWidth, canvasHeight), 0, 0, 20, 1000 / 60)
      // }
      // 滤镜实现淡出动画 end
      // 裁剪 + 滤镜 start
      // const image = new Image()
      // const sunglassFilter = new Worker('../worker/sunglassFilter.js')
      // const LENS_RADIUS = canvasWidth / 5
      // const offsetCanvas = document.createElement('canvas')
      // const offsetContext = offsetCanvas.getContext('2d')
      // offsetCanvas.width = canvasWidth
      // offsetCanvas.height = canvasHeight

      // function putSunglassesOn() {
      //   const imageData = context.getImageData(0, 0, canvasWidth, canvasHeight)
      //   const center = {
      //     x: canvasWidth / 2, y: canvasHeight / 2
      //   }
      //   const leftLensLoction = {
      //     x: center.x - LENS_RADIUS - 10,
      //     y: center.y
      //   }
      //   const rightLensLoction = {
      //     x: center.x + LENS_RADIUS + 10,
      //     y: center.y
      //   }

      //   sunglassFilter.postMessage(imageData)

      //   sunglassFilter.onmessage = function (event) {
      //     offsetContext.putImageData(event.data, 0, 0)
      //     drawLenses(leftLensLoction, rightLensLoction)
      //     drawWire(center)
      //     drawConnectors(center)
      //   }
      // }
      // function drawLenses(leftLensLoction, rightLensLoction) {
      //   context.save()
      //   context.beginPath()
      //   context.arc(leftLensLoction.x, leftLensLoction.y, LENS_RADIUS, 0, Math.PI * 2, false)
      //   context.stroke()
      //   context.moveTo(rightLensLoction.x, rightLensLoction.y)
      //   context.arc(rightLensLoction.x, rightLensLoction.y, LENS_RADIUS, 0, Math.PI * 2, false)
      //   context.stroke()
      //   context.clip()
      //   context.drawImage(offsetCanvas, 0, 0, canvasWidth, canvasHeight)
      //   context.restore()

      // }
      // function drawWire(center) {
      //   context.beginPath()
      //   context.moveTo(center.x - LENS_RADIUS / 4, center.y - LENS_RADIUS / 2)
      //   context.quadraticCurveTo(center.x, center.y - LENS_RADIUS + 20, center.x + LENS_RADIUS / 4, center.y - LENS_RADIUS / 2)
      //   context.stroke()
      // }
      // function drawConnectors(center) {
      //   context.beginPath()
      //   context.fillStyle = 'silver'
      //   context.strokeStyle = 'rgba(0,0,0,0.4)'
      //   context.lineWidth = 2
      //   context.arc(center.x - LENS_RADIUS / 4, center.y - LENS_RADIUS / 2, 4, 0, Math.PI * 2, false)
      //   context.fill()
      //   context.stroke()

      //   context.beginPath()
      //   context.arc(center.x + LENS_RADIUS / 4, center.y - LENS_RADIUS / 2, 4, 0, Math.PI * 2, false)
      //   context.fill()
      //   context.stroke()
      // }

      // image.src = '../images/2.jpg'
      // image.onload = function () {
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      // }
      // canvas.onclick = function () {
      //   putSunglassesOn()
      // }
      // 裁剪 + 滤镜 end
      // 墨镜滤镜 start
      // const image = new Image()
      // const sunglassFilter = new Worker('../worker/sunglassFilter.js')
      // image.src = '../images/2.jpg'
      // image.onload = function () {
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      // }
      // function putSunglassesOn() {
      //   sunglassFilter.postMessage(context.getImageData(0, 0, canvasWidth, canvasHeight))
      //   sunglassFilter.onmessage = function (event) {
      //     context.putImageData(event.data, 0, 0)
      //     sunglassFilter.terminate()
      //   }
      // }
      // canvas.onclick = function () {
      //   putSunglassesOn()
      // }
      // 墨镜滤镜 end
      // 浮雕滤镜效果 start
      // const image = new Image()
      // image.src = '../images/4.jpg'
      // image.onload = function () {
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      // }
      // function emboss() {
      //   let imageData, data, length, width, index = 3

      //   imageData = context.getImageData(0, 0, canvasWidth, canvasHeight)
      //   data = imageData.data
      //   width = imageData.width
      //   length = data.length
      //   // 遍历每一个像素的分量值
      //   for (let i = 0; i < length; i++) {
      //     // 处理不是最后一行的
      //     if (i <= length - width * 4) {
      //       // 不处理 alpha
      //       if ((i + 1) % 4 !== 0) {
      //         // 如果是本行最后一个像素，由于右边没有像素值，所以取前一个像素的值
      //         if ((i + 4) % (width * 4) === 0) {
      //           data[i] = data[i - 4]
      //           data[i + 1] = data[i - 3]
      //           data[i + 2] = data[i - 2]
      //           data[i + 3] = data[i - 1]
      //           i += 3
      //         } else {
      //           data[i] = 255 / 2 + data[i] * 2 - data[i + 4] - data[i + width * 4]
      //         }
      //       }
      //     } else { // 最后一行
      //       if ((i + 1) % 4 !== 0) {
      //         // 取上一行像素的分量值
      //         data[i] = data[i - width * 4]
      //       }
      //     }
      //   }

      //   context.putImageData(imageData, 0, 0)
      // }
      // canvas.onclick = function () {
      //   emboss()
      // }
      // 浮雕滤镜效果 end
      // 黑白滤镜效果 start
      // const image = new Image()
      // image.src = '../images/2.jpg'
      // image.onload = function () {
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      // }
      // canvas.onclick = function () {
      //   const imageData = context.getImageData(0, 0, canvasWidth, canvasHeight)
      //   const data = imageData.data

      //   for (let i = 0; i < data.length - 4; i += 4) {
      //     const average = (data[i] + data[i + 1] + data[i + 2]) / 3
      //     data[i] = average
      //     data[i + 1] = average
      //     data[i + 2] = average
      //   }

      //   context.putImageData(imageData, 0, 0)
      // }
      // 黑白滤镜效果 end
      // 负片滤镜效果 start
      // const image = new Image()
      // image.src = '../images/5.jpg'
      // image.onload = function () {
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      // }
      // canvas.onclick = function () {
      //   const imageData = context.getImageData(0, 0, canvasWidth, canvasHeight)
      //   const data = imageData.data

      //   for (let i = 0; i < data.length - 4; i += 4) {
      //     data[i] = 255 - data[i]
      //     data[i + 1] = 255 - data[i + 1]
      //     data[i + 2] = 255 - data[i + 2]
      //   }

      //   context.putImageData(imageData, 0, 0)
      // }
      // 负片滤镜效果 end

      // 修改图像数据 start
      // const mousedown = {}
      // const rubberbandRectangle = {}
      // let imageWidth,
      //   imageHeight,
      //   imageData,
      //   imageDataCopy = context.createImageData(canvasWidth, canvasHeight),
      //   dragging = false

      // const image = new Image()
      // image.src = '../images/5.jpg'
      // image.onload = function () {
      //   context.drawImage(image, 0, 0, canvasWidth, canvasHeight)
      // }

      // function setRubberbandRectangle(x, y) {
      //   rubberbandRectangle.left = Math.min(x, mousedown.x)
      //   rubberbandRectangle.top = Math.min(y, mousedown.y)
      //   rubberbandRectangle.width = Math.abs(x - mousedown.x)
      //   rubberbandRectangle.height = Math.abs(y - mousedown.y)
      // }

      // function copyCanvasPixels() {
      //   let i = 0
      //   for (; i < 3; i++) {
      //     imageDataCopy.data[i] = imageData.data[i]
      //   }
      //   for (i = 3; i < imageData.data.length - 4; i += 4) {
      //     imageDataCopy.data[i] = imageData.data[i] / 2
      //     imageDataCopy.data[i + 1] = imageData.data[i + 1]
      //     imageDataCopy.data[i + 2] = imageData.data[i + 2]
      //     imageDataCopy.data[i + 3] = imageData.data[i + 3]
      //   }
      // }

      // function captureCanvasPixels() {
      //   imageData = context.getImageData(0, 0, canvasWidth, canvasHeight)
      //   copyCanvasPixels()
      // }

      // function restoreRubberbandPixels() {
      //   const deviceWidthOverCSSPixels = imageData.width / canvas.width
      //   const deviceHeightOverCSSPixels = imageData.height / canvas.height

      //   context.putImageData(imageData, 0, 0)

      //   context.putImageData(
      //     imageDataCopy,
      //     0,
      //     0,
      //     rubberbandRectangle.left + context.lineWidth,
      //     rubberbandRectangle.top + context.lineWidth,
      //     (rubberbandRectangle.width - context.lineWidth * 2) * deviceWidthOverCSSPixels,
      //     (rubberbandRectangle.height - context.lineWidth * 2) * deviceHeightOverCSSPixels
      //   )
      // }

      // function drawRubberband() {
      //   context.strokeRect(rubberbandRectangle.left + context.lineWidth, rubberbandRectangle.top + context.lineWidth, rubberbandRectangle.width - context.lineWidth * 2, rubberbandRectangle.height - context.lineWidth * 2)
      // }

      // function rubberbandStart(x, y) {
      //   mousedown.x = x
      //   mousedown.y = y

      //   rubberbandRectangle.left = x
      //   rubberbandRectangle.top = y
      //   rubberbandRectangle.width = 0
      //   rubberbandRectangle.height = 0

      //   dragging = true

      //   captureCanvasPixels()
      // }
      // function rubberbandStretch(x, y) {
      //   if (rubberbandRectangle.width > context.lineWidth * 2 && rubberbandRectangle.height > context.lineWidth * 2) {
      //     if (imageData !== undefined) {
      //       restoreRubberbandPixels()
      //     }
      //   }

      //   setRubberbandRectangle(x, y)

      //   if (rubberbandRectangle.width > context.lineWidth * 2 && rubberbandRectangle.height > context.lineWidth * 2) {
      //     drawRubberband()
      //   }
      // }
      // function rubberbandEnd() {
      //   context.putImageData(imageData, 0, 0)

      //   context.drawImage(canvas, rubberbandRectangle.left + context.lineWidth * 2, rubberbandRectangle.top + context.lineWidth * 2, rubberbandRectangle.width - context.lineWidth * 4, rubberbandRectangle.height - context.lineWidth * 4, 0, 0, canvasWidth, canvasHeight)

      //   dragging = false
      //   imageData = undefined
      // }

      // canvas.onmousedown = function (e) {
      //   const loc = windowToCanvas(canvas, e.clientX, e.clientY)
      //   e.preventDefault()
      //   rubberbandStart(loc.x, loc.y)
      // }
      // canvas.onmousemove = function (e) {
      //   if (dragging) {
      //     const loc = windowToCanvas(canvas, e.clientX, e.clientY)
      //     rubberbandStretch(loc.x, loc.y)
      //   }
      // }
      // canvas.onmouseup = function () {
      //   rubberbandEnd()
      // }

      // context.strokeStyle = 'navy'
      // context.lineWidth = 1
      // 修改图像数据 end

      // 图片居中伸缩 start
      // canvas.width = 300
      // canvas.height = 300
      // document.body.style.backgroundColor = '#eee'
      // canvas.style.top = '30px'
      // canvas.style.left = '30px'

      // const image = new Image()
      // image.src = '../images/1.jpg'
      // image.onload = function () {
      //   const w = image.width
      //   const h = image.height

      //   const left = (w - 300) / 2
      //   const top = (h - 300) / 2

      //   context.drawImage(image, left, top, w, h, 0, 0, w, h)
      // }
      // 图片居中伸缩 end

      // 在圆弧周围绘制文字 start
      // const TEXT_FILL_STYLE = 'rgba(100, 130, 240, 0.5)'
      // const TEXT_STROKE_STYLE = 'rgba(200, 0, 0, 0.7)'
      // const TEXT_SIZE = 64
      // const circle = {
      //   x: canvasWidth / 2,
      //   y: canvasHeight / 2,
      //   radius: 200
      // }

      // function drawCircularText(string, startAngle, endAngle) {
      //   const { radius } = circle
      //   const angleDecrement = (startAngle - endAngle) / (string.length - 1)
      //   let angle = parseFloat(startAngle)
      //   let index = 0
      //   let character

      //   context.save()

      //   context.fillStyle = TEXT_FILL_STYLE
      //   context.strokeStyle = TEXT_STROKE_STYLE
      //   context.font = TEXT_SIZE + 'px Lucida Sans'

      //   while (index < string.length) {
      //     character = string.charAt(index)

      //     context.save()
      //     context.beginPath()

      //     context.translate(
      //       circle.x + Math.cos(angle) * radius,
      //       circle.y - Math.sin(angle) * radius
      //     )
      //     context.rotate(Math.PI / 2 - angle)

      //     context.fillText(character, 0, 0)
      //     context.strokeText(character, 0, 0)

      //     angle -= angleDecrement
      //     index++

      //     context.restore()
      //   }
      // }

      // context.textAlign = 'center'
      // context.textBaseline = 'middle'
      // drawCircularText('Clockwise around the circle', Math.PI * 2, Math.PI / 8)
      // 在圆弧周围绘制文字 end

      // 裁剪伸缩效果 start
      // let loop = null
      // function fillCanvas(color) {
      //   context.fillStyle = color
      //   context.fillRect(0, 0, canvasWidth, canvasHeight)
      // }

      // function setClippingRegion(radius) {
      //   context.beginPath()
      //   context.arc(middleX, middleY - 50, radius, 0, Math.PI * 2)
      //   context.clip()
      // }

      // function drawText() {
      //   context.save()

      //   const text = '新年快乐'
      //   context.fillStyle = 'OrangeRed'
      //   context.font = 'bold 150px arial'
      //   context.fillText(text, canvasWidth / 2 - context.measureText(text).width / 2, canvasHeight / 2)

      //   context.restore()
      // }
      // function endAnimation(loop) {
      //   clearInterval(loop)

      //   setTimeout(() => {
      //     context.clearRect(0, 0, canvasWidth, canvasHeight)
      //     drawText()
      //   }, 1000)
      // }
      // function animate() {
      //   let radius = Math.sqrt(middleX * middleX + middleY * middleY)
      //   loop = setInterval(() => {
      //     radius -= canvasWidth / 200
      //     fillCanvas('charcoal')
      //     if (radius > 0) {
      //       context.save()
      //       setClippingRegion(radius)
      //       fillCanvas('white')
      //       drawText()
      //       context.restore()
      //     } else {
      //       endAnimation(loop)
      //     }
      //   }, 16)
      // }
      // canvas.onmousedown = function () {
      //   animate()
      // }
      // drawText()
      // 裁剪伸缩效果 end

      // 绘制扇形 start
      // const data = [0.05, 0.25, 0.6, 0.1]
      // data.forEach((item, i) => {
      //   if (i > 0) {
      //     data[i] += data[i - 1]
      //   }
      // })
      // const angles = data.map(item => {
      //   return item * 360 * Math.PI / 180
      // })
      // const radius = 150
      // const fillStyles = ['blue', 'red', 'green', 'OrangeRed']

      // context.translate(400, 400)

      // for (let i = 0; i < data.length; i++) {
      //   context.beginPath()
      //   context.fillStyle = fillStyles[i]
      //   context.moveTo(0, 0)
      //   context.arc(0, 0, radius, angles[i - 1] || 0, angles[i])
      //   context.closePath()
      //   context.fill()
      // }
      // 绘制扇形 end

      // 绘制欣宇的贺卡 start
      // const hw = 80.4 * 5
      // const hh = 113.7 * 6
      // const title = '新年快乐'
      // const text = [
      //   '祝欣宇老师在新的一年',
      //   '牛气冲天',
      //   '牛运亨通',
      //   '牛转乾坤',
      //   '牛年大吉',
      //   '',
      //   '财源滚滚',
      //   '好事连连',
      //   '笑口常开',
      //   '心想事成',
      //   '',
      //   '秀发飘飘',
      //   '钱包满满',
      //   '多吃不胖',
      //   '睡觉倍儿棒',
      //   '',
      //   '过年好！'
      // ]
      // const img = new Image()
      // img.src = '../images/hongbao2.jpg'
      // img.onload = function () {
      //   context.drawImage(img, 0, 0, 804, 113.7 * 4, 0, 0, hw, 113.7 * 2.4)
      //   context.drawImage(img, 0, 113.7 * 4, 804, 113.7 * 3, 0, 113.7 * 2.4, hw, 113.7 * 1.8)
      //   context.drawImage(img, 0, 113.7 * 4, 804, 113.7 * 3, 0, 113.7 * 3.6, hw, 113.7 * 1.8)
      //   context.drawImage(img, 0, 113.7 * 4, 804, 113.7 * 3, 0, 113.7 * 5.4, hw, 113.7 * 1.8)
      //   context.drawImage(img, 0, 113.7 * 7, 804, 113.7 * 3, 0, 113.7 * 7.2, hw, 113.7 * 1.8)
      //   drawTitle()
      //   drawText()
      //   drawLaugh()
      // }
      // function drawTitle() {
      //   context.font = 'bold 50px STKaiti'
      //   context.fillStyle = '#fdda01'
      //   context.fillText(title, hw / 2 - context.measureText(title).width / 2, 150)
      // }
      // function drawText() {
      //   const top = 300
      //   context.fillStyle = '#fcce92'
      //   context.font = '30px STKaiti'
      //   text.forEach((t, i) => {
      //     let textTop, textLeft = hw / 2 - context.measureText(t).width / 2
      //     if (i === 0) {
      //       textTop = top - 30
      //     } else {
      //       textTop = top + i * 32
      //     }
      //     context.fillText(t, textLeft, textTop)
      //   })
      // }
      // function drawLaugh() {
      //   const img = new Image()
      //   img.src = '../images/laugh.png'
      //   img.onload = function () {
      //     context.drawImage(img, hw / 2 - 50, 113.7 * 7.5, 80, 80)
      //   }
      // }
      // canvas.onclick = () => {
      //   const img = document.getElementById('img')
      //   context.imageSmoothingEnabled = false
      //   img.src = canvas.toDataURL('image/jpg')
      // }
      // 绘制欣宇的贺卡 end

      // context.globalCompositeOperation = 'xor'

      // context.fillStyle = 'OrangeRed'
      // context.arc(100, 100, 100, 0, Math.PI * 2)
      // context.fill()

      // context.beginPath()
      // context.fillStyle = '#08c'
      // context.arc(200, 200, 100, 0, Math.PI * 2)
      // context.fill()

      // context.strokeStyle = 'OrangeRed'
      // context.fillStyle = '#08c'
      // context.lineWidth = 20
      // context.moveTo(0, 0)
      // context.lineTo(canvasWidth, canvasHeight)
      // context.stroke()

      // context.save()
      // context.translate(30, 30)
      // context.arc(0, 0, 30, 0, Math.PI * 2)
      // context.stroke()
      // context.restore()

      // context.beginPath()
      // context.translate(60, 60)
      // context.arc(0, 0, 30, 0, Math.PI * 2)
      // context.stroke()

      // document.addEventListener('click', e => {
      //   console.log(context.isPointInPath(e.clientX, e.clientY))
      // })
      // 三次贝塞尔曲线箭头 end
      // const entPoints = [{ x: 130, y: 70 }, { x: 430, y: 270 }]
      // const controlPoints = [{ x: 130, y: 250 }, { x: 450, y: 70 }]

      // function drawControlPoints() {
      //   context.strokeStyle = 'yellow'
      //   context.fillStyle = 'blue'
      //   controlPoints.forEach(point => {
      //     context.beginPath()
      //     context.arc(point.x, point.y, 5, 0, Math.PI * 2, false)
      //     context.stroke()
      //     context.fill()
      //   })
      // }
      // function drawEndPoints() {
      //   context.strokeStyle = 'blue'
      //   context.fillStyle = 'red'
      //   entPoints.forEach(point => {
      //     context.beginPath()
      //     context.arc(point.x, point.y, 5, 0, Math.PI * 2, false)
      //     context.stroke()
      //     context.fill()
      //   })
      // }
      // function drawBezierCurve() {
      //   context.strokeStyle = 'blue'
      //   context.beginPath()
      //   context.moveTo(entPoints[0].x, entPoints[0].y)
      //   context.bezierCurveTo(
      //     controlPoints[0].x, controlPoints[0].y,
      //     controlPoints[1].x, controlPoints[1].y,
      //     entPoints[1].x, entPoints[1].y
      //   )
      //   context.stroke()
      // }

      // drawGrid(context, 'lightgray', 10, 10)
      // drawControlPoints()
      // drawEndPoints()
      // drawBezierCurve()
      // 三次贝塞尔曲线箭头 end

      // 二次贝塞尔曲线箭头 start
      // const ARROW_MARGIN = 30
      // const POINT_RADIUS = 7
      // const points = [
      //   {
      //     x: canvasWidth - ARROW_MARGIN,
      //     y: canvasHeight - ARROW_MARGIN
      //   },
      //   {
      //     x: canvasWidth - ARROW_MARGIN * 2,
      //     y: canvasHeight - ARROW_MARGIN
      //   },
      //   {
      //     x: POINT_RADIUS,
      //     y: canvasHeight / 2
      //   },
      //   {
      //     x: ARROW_MARGIN,
      //     y: canvasHeight / 2 - ARROW_MARGIN
      //   },
      //   {
      //     x: canvasWidth - ARROW_MARGIN,
      //     y: ARROW_MARGIN
      //   },
      //   {
      //     x: canvasWidth - ARROW_MARGIN,
      //     y: ARROW_MARGIN * 2
      //   }
      // ]

      // function drawPoint(x, y, strokeStyle, fillStyle) {
      //   context.beginPath()
      //   context.fillStyle = fillStyle
      //   context.strokeStyle = strokeStyle
      //   context.lineWidth = 0.5
      //   context.arc(x, y, POINT_RADIUS, 0, Math.PI * 2, false)
      //   context.fill()
      //   context.stroke()
      // }
      // function drawArrow() {
      //   context.strokeStyle = 'white';
      //   context.fillStyle = 'cornflowerblue'
      //   context.moveTo(canvasWidth - ARROW_MARGIN, ARROW_MARGIN * 2)
      //   context.lineTo(canvasWidth - ARROW_MARGIN, canvasHeight - ARROW_MARGIN * 2)
      //   context.quadraticCurveTo(points[0].x, points[0].y, points[1].x, points[1].y)
      //   context.lineTo(ARROW_MARGIN, canvasHeight / 2 + ARROW_MARGIN)
      //   context.quadraticCurveTo(points[2].x, points[2].y, points[3].x, points[3].y)
      //   context.lineTo(canvasWidth - ARROW_MARGIN * 2, ARROW_MARGIN)
      //   context.quadraticCurveTo(points[4].x, points[4].y, points[5].x, points[5].y)
      //   context.fill()
      //   context.stroke()
      // }
      // function drawBezierPoints() {
      //   let i, strokeStyle, fillStyle
      //   for (let i = 0; i < points.length; i++) {
      //     fillStyle = i % 2 === 0 ? 'white' : 'blue'
      //     strokeStyle = i % 2 === 0 ? 'blue' : 'white'
      //     drawPoint(points[i].x, points[i].y, strokeStyle, fillStyle)
      //   }
      // }

      // context.clearRect(0, 0, canvasWidth, canvasHeight)
      // drawArrow()
      // drawBezierPoints()
      // 二次贝塞尔曲线箭头 end

      // context.fillStyle = "cornflowerblue";
      // context.strokeStyle = "OrangeRed";

      // context.shadowColor = "rgba(50, 50, 50, 1.0)";
      // context.shadowOffsetX = 2;
      // context.shadowOffsetY = 2;
      // context.shadowBlur = 4;

      // context.lineWidth = 20;
      // context.lineCap = "round";

      // context.beginPath();
      // context.moveTo(120.5, 130);
      // context.quadraticCurveTo(150.8, 130, 160.6, 150.5);
      // context.quadraticCurveTo(190, 250.0, 210.5, 160.5);
      // context.quadraticCurveTo(240, 100.5, 290, 70.5);

      // context.stroke();

      // context.lineWidth = 20
      // context.moveTo(100, 100)
      // context.lineTo(500, 100)
      // context.lineTo(100, 500)

      // context.lineCap = 'round'
      // context.lineJoin = 'bevel'
      // context.miterLimit = 20 // 斜接线与二分之一线宽的比值
      // context.stroke()

      //  扩展 canvasRenderingContent2D 绘制虚线 start
      // const moveToFunction = CanvasRenderingContext2D.prototype.moveTo
      // CanvasRenderingContext2D.prototype.lastMoveToLocation = {}
      // CanvasRenderingContext2D.prototype.moveTo = function (x, y) {
      //   moveToFunction.apply(context, [x, y])
      //   this.lastMoveToLocation.x = x
      //   this.lastMoveToLocation.y = y
      // }
      // CanvasRenderingContext2D.prototype.dashedLineTo = function (x, y, dashLength) {
      //   dashLength = dashLength === undefined ? 5 : dashLength;
      //   const startX = this.lastMoveToLocation.x
      //   const startY = this.lastMoveToLocation.y
      //   const deltaX = x - startX
      //   const deltaY = y - startY
      //   const numDashes = Math.floor(
      //     Math.sqrt(deltaX * deltaX + deltaY * deltaY) / dashLength
      //   );

      //   for (let i = 0; i < numDashes; i++) {
      //     context[i % 2 === 0 ? "moveTo" : "lineTo"](
      //       startX + (deltaX / numDashes) * i,
      //       startY + (deltaY / numDashes) * i
      //     );
      //   }

      //   this.moveTo(x, y)
      // }
      // context.moveTo(10, 10)
      // context.dashedLineTo(100, 10)
      // context.dashedLineTo(100, 100)
      // context.strokeStyle = 'OrangeRed'
      // context.stroke()
      // 扩展 canvasRenderingContent2D 绘制虚线 end

      // 绘制虚线 start
      // function drawDashedLine(context, x1, y1, x2, y2, dashLength) {
      //   dashLength = dashLength === undefined ? 5 : dashLength
      //   const deltaX = x2 - x1
      //   const deltaY = y2 - y1
      //   const numDashes = Math.floor(
      //     Math.sqrt(deltaX * deltaX + deltaY * deltaY) / dashLength
      //   )

      //   for (let i = 0; i < numDashes; i++) {
      //     context[i % 2 === 0 ? 'moveTo' : 'lineTo'](x1 + (deltaX / numDashes) * i, y1 + (deltaY / numDashes) * i)
      //   }

      //   context.stroke()
      // }
      // context.lineWidth = 3
      // context.strokeStyle = 'OrangeRed'
      // drawDashedLine(context, 20, 20, context.canvas.width - 20, 20)
      // drawDashedLine(context, context.canvas.width - 20, 20, context.canvas.width - 20, context.canvas.height - 20, 10)
      // 绘制虚线 end

      // function drawGrid(context, color, stepx, stepy) {
      //   const { width, height } = context.canvas;
      //   context.strokeStyle = color;
      //   context.lineWidth = 0.5;

      //   for (let i = stepx + 0.5; i < width; i += stepx + 1) {
      //     context.beginPath();
      //     context.moveTo(i, 0);
      //     context.lineTo(i, height);
      //     context.stroke();
      //   }
      //   for (let i = stepy + 0.5; i < height; i += stepy + 1) {
      //     context.beginPath();
      //     context.moveTo(0, i);
      //     context.lineTo(width, i);
      //     context.stroke();
      //   }
      // }
      // drawGrid(context, "OrangeRed", 10, 10);

      // context.lineWidth = 1;
      // context.beginPath();
      // context.moveTo(50, 10);
      // context.lineTo(450, 10);
      // context.stroke();
      // context.beginPath();
      // context.moveTo(50.5, 50.5);
      // context.lineTo(450.5, 50.5);
      // context.stroke();
      // 裁剪图形
      // context.fillStyle = "Darkorange";
      // context.strokeStyle = "rgba(0, 0, 0, 0.7)";

      // context.beginPath();

      // context.rect(0, 0, canvasWidth, canvasHeight);

      // rect(context, 100, 100, 100, 100, true);

      // context.moveTo(150, 300); // 消除画圆之前子路径终点与圆的起点之间的连线
      // context.arc(100, 300, 50, 0, Math.PI * 2, true);

      // context.moveTo(600, 600);
      // context.lineTo(500, 600);
      // context.lineTo(600, 700);

      // context.closePath();

      // context.fill();
      // context.stroke();
      // -----------------------------------------------------
      // context.fillStyle = "#08c";
      // context.shadowColor = "rgba(0, 0, 0, 0.8)";
      // context.shadowOffsetX = 12;
      // context.shadowOffsetY = 12;
      // context.shadowBlur = 15;
      // context.arc(500, 500, 300, 0, Math.PI * 2);
      // context.arc(500, 500, 400, 0, Math.PI * 2, true);
      // context.fill();

      // context.beginPath();
      // context.rect(100, 100, 100, 100);
      // context.stroke();

      // context.beginPath();
      // context.rect(500, 500, 100, 100);
      // context.stroke();
      // 阴影
      // 内凹效果的橡皮擦 start
      // context.lineWidth = 1;
      // context.shadowColor = "blue";
      // context.shadowOffsetX = -5;
      // context.shadowOffsetY = -5;
      // context.shadowBlur = 20;
      // context.strokeStyle = "rgba(0,0,255,0.6)";

      // context.beginPath();
      // context.arc(
      //   canvasWidth / 2,
      //   canvasHeight / 2,
      //   300,
      //   0,
      //   Math.PI * 2,
      //   false
      // );
      // context.clip();
      // context.stroke();
      // 内凹效果的橡皮擦 end

      // function drawShadow(color) {
      //   context.shadowColor = color
      //   context.shadowOffsetX = 2
      //   context.shadowOffsetY = -2
      //   context.shadowBlur = 5

      //   context.fillStyle = '#08c'
      //   context.fillRect(100, 100, 100, 50)
      // }
      // drawShadow('rgba(0, 0, 0, 0.7)')

      // document.body.addEventListener('click', () => {
      //   context.clearRect(0, 0, canvasWidth, canvasHeight)
      //   drawShadow('rgba(0,0,0,0)')
      // })

      // 图案
      // const img = new Image()

      // function fillCanvasWithPattern(repeatString) {
      //   const pattern = context.createPattern(img, repeatString)
      //   context.clearRect(0, 0, canvasWidth, canvasHeight)
      //   context.fillStyle = pattern
      //   context.fillRect(0, 0, canvasWidth, canvasHeight)
      //   // context.fill()
      //   requestAnimationFrame(fillCanvasWithPattern.bind(this, repeatString))
      // }
      // img.src = '../images/5.jpg'
      // img.onload = () => {
      //   fillCanvasWithPattern('no-repeat')
      // }

      // 径向渐变
      // const radialGradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 10, canvas.width / 2, 0, 100)
      // radialGradient.addColorStop(0, 'blue')
      // radialGradient.addColorStop(0.25, 'white')
      // radialGradient.addColorStop(0.5, 'purple')
      // radialGradient.addColorStop(0.65, 'red')
      // radialGradient.addColorStop(1, 'yellow')

      // context.fillStyle = radialGradient
      // context.rect(0, 0, canvas.width, canvas.height)
      // context.fill()

      // 线性渐变
      // const gradient = context.createLinearGradient(325, 100, 525, 100)
      // gradient.addColorStop(0, 'blue')
      // gradient.addColorStop(0.25, 'white')
      // gradient.addColorStop(0.5, 'purple')
      // gradient.addColorStop(0.65, 'red')
      // gradient.addColorStop(1, 'yellow')

      // context.lineJoin = 'round'
      // context.lineWidth = 30

      // context.font = '24px Helvetica'
      // context.fillText('click anywhere to erase', 175, 200)

      // context.strokeStyle = 'darksalmon'
      // context.fillStyle = gradient

      // context.strokeRect(75, 100, 200, 200)
      // context.fillRect(325, 100, 200, 200)

      // canvas.addEventListener('mousedown', e => {
      //   context.clearRect(0, 0, documentWidth, documentHeight)
      // })
  </script>
</body>

</html>